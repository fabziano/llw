{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Configura\u00e7\u00e3o de Ambiente Distribu\u00eddo com Alta Disponibilidade, Seguran\u00e7a e Autentica\u00e7\u00e3o Unificada","text":"<p>Este documento explica nossos passos na aplica\u00e7\u00e3o do TLS, substituindo HTTP por HTTPS em todas as conex\u00f5es entre as VMs Frontend, Backend e Database.</p>"},{"location":"#1-gerando-certificados-digitais-autoassinados","title":"1. Gerando certificados digitais autoassinados","text":""},{"location":"#11-gerar-a-chave-privada-da-ca","title":"1.1 - Gerar a chave privada da CA","text":"<pre><code>openssl genrsa -out llw-ca.key 4096\n</code></pre>"},{"location":"#12-gerar-o-certificado-da-ca","title":"1.2 Gerar o certificado da CA","text":"<pre><code>openssl req -x509 -new -nodes -key llw-ca.key -sha256 -days 365 \\\n  -out llw-ca.crt \\\n  -subj \"/C=BR/ST=Parana/L=Foz/O=LionLaw/CN=LLW-CA\"\n</code></pre>"},{"location":"#13-arquivo-de-configuracao-para-san-subject-alternative-names","title":"1.3 Arquivo de configura\u00e7\u00e3o para SAN (Subject Alternative Names)","text":"<p>Utilizamos o conte\u00fado desse arquivo llw-cert.cnf como base para cria\u00e7\u00e3o de nosso certificado.</p> <pre><code>[req]\ndefault_bits = 2048\nprompt = no\ndefault_md = sha256\nreq_extensions = req_ext\ndistinguished_name = dn\n\n[dn]\nC = BR\nST = Parana\nL = Foz\nO = LionLaw\nCN = llw.local\n\n[req_ext]\nsubjectAltName = @alt_names\n\n[alt_names]\nDNS.1 = frontend.llw\nDNS.2 = backend.llw\nDNS.3 = database.llw\n</code></pre> <p>Esse certificado foi utilizado para todas as conex\u00f5es do nosso projeto por isso ter\u00e1 v\u00e1rios \"subject alternative names\" (SAN).</p>"},{"location":"#14-gerar-chave-privada-e-csr-com-sans","title":"1.4 Gerar chave privada e CSR com SANs","text":"<pre><code>openssl req -new -nodes -out llw.csr -newkey rsa:2048 -keyout llw.key -config llw-cert.cnf\n</code></pre>"},{"location":"#15-gerar-e-assinar-o-certificado-usando-a-ca","title":"1.5 Gerar e assinar o certificado usando a CA","text":"<pre><code>openssl x509 -req -in llw.csr -CA llw-ca.crt -CAkey llw-ca.key -CAcreateserial \\\n  -out llw.crt -days 365 -sha256 -extfile llw-cert.cnf -extensions req_ext\n</code></pre>"},{"location":"#2-configurando-o-nginx-para-usar-tls","title":"2. Configurando o NGINX para usar TLS","text":""},{"location":"#21-modificar-o-arquivo-de-configuracao-do-nginx","title":"2.1  Modificar o arquivo de configura\u00e7\u00e3o do nginx","text":"<p>Adicionamos as seguintes configura\u00e7\u00f5es e modificamos as j\u00e1 existentes no arquivo de configura\u00e7\u00e3o do nginx (/etc/nginx/http.d/default.conf).</p> <pre><code>server {\n    listen 443 ssl;\n    listen [::]:443 ssl;\n\n    http2 on;\n\n    ssl_certificate /etc/ssl/certs/llw.crt;\n    ssl_certificate_key /etc/ssl/private/llw.key;\n\n    # HSTS (ngx_http_headers_module is required) (63072000 seconds)\n    add_header Strict-Transport-Security \"max-age=63072000\" always;\n}\n\n# HSTS Redirect\nserver {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n\n    return 301 https://$host$request_uri;\n}\n\nssl_ecdh_curve X25519:prime256v1:secp384r1;\nssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA2ssl_session_cache shared:MozSSL:10m;\nssl_dhparam \"/etc/ssl/dhparam\";\n</code></pre> <p>Configura\u00e7\u00e3o gerada pelo Mozilla SSL Configuration Generator para o nginx, configura\u00e7\u00e3o intermedi\u00e1ria e com HSTS.</p>"},{"location":"#22-baixar-o-dhparam","title":"2.2 Baixar o DHParam","text":"<pre><code>curl https://ssl-config.mozilla.org/ffdhe2048.txt &gt; /etc/ssl/dhparam\n</code></pre> <p>Tamb\u00e9m utilizamos o sugerido pelo pr\u00f3prio site da Mozilla</p>"},{"location":"#23-copiar-os-certificados-para-os-diretorios-corretos","title":"2.3 Copiar os certificados para os diret\u00f3rios corretos","text":"<pre><code>cp llw.crt /etc/ssl/certs/llw.crt\ncp llw.key /etc/ssl/private/llw.key\n</code></pre> <p>Ap\u00f3s esses passos (e reiniciando o nginx) j\u00e1 foi poss\u00edvel acessar nosso front utilizando HTTPS ao inv\u00e9s de HTTP, ser\u00e1 necess\u00e1rio uma confirma\u00e7\u00e3o para prosseguir, pois o navegador n\u00e3o confia em certificado auto-assinados de cara.</p>"},{"location":"#3-baixando-e-instalando-o-tomcat","title":"3. Baixando e instalando o Tomcat","text":"<p>Para podermos utilizar o Tomcat tivemos que baixar e fazer a instala\u00e7\u00e3o manualmente, devido a aus\u00eancia do servi\u00e7o nos reposit\u00f3rios oficiais da distro que estamos utilizando (Alpine Linux).</p>"},{"location":"#31-baixando-o-arquivo-compactado","title":"3.1 Baixando o arquivo compactado","text":"<pre><code>wget https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.41/bin/apache-tomcat-10.1.41.tar.gz\n</code></pre> <p>Arquivo .tar.gz da vers\u00e3o 10.1.41 do tomcat, obtida do site oficial do Apache Tomcat.</p>"},{"location":"#32-extraindo-o-conteudo","title":"3.2 Extraindo o conte\u00fado","text":"<pre><code>tar -xvzf apache-tomcat-10.1.41.tar.gz\n</code></pre>"},{"location":"#33-movendo-para-uma-pasta-apropriada","title":"3.3 Movendo para uma pasta apropriada","text":"<pre><code>mv apache-tomcat-10.1.41 /etc/tomcat\n</code></pre>"},{"location":"#34-criando-um-script-de-servico","title":"3.4 Criando um script de servi\u00e7o","text":"<pre><code>nano /etc/init.d/tomcat\n</code></pre> <p>Como estamos instalando manualmente criamos um script OpenRC para trat\u00e1-lo como um service.</p>"},{"location":"#conteudo-do-script","title":"Conte\u00fado do script","text":"<pre><code>#!/sbin/openrc-run\n\ndescription=\"Apache Tomcat\"\ncommand=\"/etc/tomcat/bin/catalina.sh\"\ncommand_args=\"start\"\ncommand_background=\"yes\"\ndepend() {\n    need net\n    use dns logger\n    after firewall\n}\n\nstart() {\n    ebegin \"Starting Tomcat\"\n    ${command} start\n    eend $?\n}\n\nstop() {\n    ebegin \"Stopping Tomcat\"\n    ${command} stop\n    eend $?\n}\n\nrestart() {\n    ebegin \"Restarting Tomcat\"\n    ${command} stop\n    sleep 2\n    ${command} start\n    eend $?\n}\n</code></pre>"},{"location":"#35-tornando-o-script-executavel","title":"3.5 Tornando o script execut\u00e1vel","text":"<pre><code>chmod +x /etc/init.d/tomcat\n</code></pre>"},{"location":"#36-iniciando-o-servico","title":"3.6 - Iniciando o servi\u00e7o","text":"<pre><code>service tomcat start\n</code></pre>"},{"location":"#37-fazendo-o-iniciar-ao-ligar-a-vm","title":"3.7 - Fazendo-o iniciar ao ligar a VM","text":"<pre><code>rc-update add tomcat default\n</code></pre> <p>Agora o Tomcat j\u00e1 \u00e9 um servi\u00e7o reconhecido e j\u00e1 vai iniciar ao ligar a VM, podemos acessar sua p\u00e1gina inicial acessando em um navegador a porta 8080 padr\u00e3o que o tomcat sobe seu servi\u00e7o, por\u00e9m s\u00f3 \u00e9 poss\u00edvel acessar essa p\u00e1gina localmente. Mas \u00e9 poss\u00edvel fazer um port-forwarding no virtual-box para acessarmos do host.</p>"},{"location":"#4-configurando-o-tomcat-para-usar-tls","title":"4 - Configurando o Tomcat para usar TLS","text":""},{"location":"#41-modificando-arquivo-de-configuracao-do-tomcat-etctomcatbinserverxml","title":"4.1 - Modificando arquivo de configura\u00e7\u00e3o do Tomcat (/etc/tomcat/bin/server.xml)","text":"<pre><code>&lt;Connector\n    port=\"443\"\n    SSLEnabled=\"true\"&gt;\n\n    &lt;SSLHostConfig\n        ciphers=\"TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305\"\n        disableSessionTickets=\"true\"\n        honorCipherOrder=\"false\"\n        protocols=\"TLSv1.2,TLSv1.3\"&gt;\n\n        &lt;Certificate\n            certificateFile=\"/etc/ssl/certs/llw.crt\"\n            certificateKeyFile=\"/etc/ssl/private/llw.key\" /&gt;\n    &lt;/SSLHostConfig&gt;\n\n    &lt;UpgradeProtocol className=\"org.apache.coyote.http2.Http2Protocol\" /&gt;\n&lt;/Connector&gt;\n</code></pre>"},{"location":"#43-movendo-os-certificados-para-as-pastas-certas","title":"4.3 - Movendo os certificados para as pastas certas","text":"<pre><code>cp llw.crt /etc/ssl/certs/llw.crt\ncp llw.key /etc/ssl/private/llw.key\n</code></pre> <p>Utilizamos os certificados utilizados pelo nginx que tamb\u00e9m ser\u00e3o v\u00e1lidos para o tomcat apresentar pois possui v\u00e1rios SAN. Por padr\u00e3o o nginx confia em certificados auto-assinados, por isso n\u00e3o teremos que modificar nada para isso ocorrer. E agora o sistema j\u00e1 est\u00e1 preparado para o deploy do war.</p>"},{"location":"#5-gerando-arquivo-war-e-deploy-da-api","title":"5 - Gerando arquivo war e deploy da API","text":"<p>At\u00e9 agora utilizamos um arquivo JAR (standalone), ele j\u00e1 inclui todas as depend\u00eancias necess\u00e1rias para a execu\u00e7\u00e3o da aplica\u00e7\u00e3o, incluindo um servidor Tomcat embutido. Isso facilitava o processo de deploy, pois n\u00e3o dependia de um servidor de aplica\u00e7\u00e3o externo mas agora como lidamos com TLS usamos o tomcat por fora, e para gerarmos nosso war precisaremos modificar algumas configura\u00e7\u00f5es em nossa aplica\u00e7\u00e3o Spring, come\u00e7ando pelo pom.xml:</p>"},{"location":"#51-empacotamento","title":"5.1 - Empacotamento","text":"<pre><code>&lt;packaging&gt;war&lt;/packaging&gt;\n</code></pre> <p>Mudaremos o modo de empacotamento que por padr\u00e3o do maven \u00e9 JAR</p>"},{"location":"#52-dependencia","title":"5.2 - Depend\u00eancia","text":"<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>J\u00e1 t\u00ednhamos a depend\u00eancia mas o diferencial \u00e9 que agora o tomcat \u00e9 provido por fora por isso a linha provided.</p>"},{"location":"#53-plugin","title":"5.3 - Plugin","text":"<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;\n&lt;/plugin&gt;\n</code></pre> <p>Substituiremos o antigo spring-boot-maven-plugin pelo maven-war-plugin.</p>"},{"location":"#54-servlet-initializer","title":"5.4 - Servlet Initializer","text":"<pre><code>package com.Advocacia;\n\nimport org.springframework.boot.builder.SpringApplicationBuilder;\nimport org.springframework.boot.web.servlet.support.SpringBootServletInitializer;\n\npublic class ServletInitializer extends SpringBootServletInitializer {\n\n    @Override\n    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n        return application.sources(AdvocaciaApplication.class);\n    }\n}\n</code></pre> <p>Criaremos essa classe que servir\u00e1 a mesma fun\u00e7\u00e3o da classe main.</p>"},{"location":"#55-buildando-o-projeto","title":"5.5 Buildando o projeto","text":"<pre><code>clean package\n</code></pre> <p>Ap\u00f3s o build estar completo tivemos nosso war que para levar ao Tomcat.</p>"},{"location":"#56-deploy-do-war-no-tomcat","title":"5.6 Deploy do war no Tomcat","text":"<p>Transferimos o war para a VM podemos lev\u00e1-lo a pasta webapps dentro dos arquivos do Tomcat.</p> <pre><code>mv Advocacia.war /etc/tomcat/webapps/backend.war\n</code></pre> <p>Por padr\u00e3o o Tomcat (inicializado) ja roda autom\u00e1tico um war quando detecta alguma mudan\u00e7a ou novo arquivo;</p>"},{"location":"#57-adaptando-proxy-reverso-nginx","title":"5.7 Adaptando proxy reverso (nginx)","text":"<p>Ap\u00f3s o deploy temos nossa api rodando em https://backend.llw/backend, note que a primeira diretiva \u00e9 o caminho com nome do war ent\u00e3o para acessarmos a api de fato temos que acessar pelo nome do war, por isso teremos que adaptar o proxy reverso no nosso front, para adicionar uma diretiva extra ao redirecionar o acesso, de /api/requisi\u00e7\u00e3o para /backend/api/requisi\u00e7\u00e3o.</p> <pre><code>location /api/ {\n        proxy_pass https://backend.llw/backend/api/;\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_pass_request_headers on;\n        proxy_pass_request_body on;\n    }\n</code></pre> <p>Tamb\u00e9m modificamos a requisi\u00e7\u00e3o de HTTP para HTTPS, n\u00e3o sendo necess\u00e1rio explicitar a porta 443 pois j\u00e1 \u00e9 a padr\u00e3o do protocolo.</p>"},{"location":"#58-modificando-o-front-end","title":"5.8 Modificando o front-end","text":"<p>Tamb\u00e9m ser\u00e1 necess\u00e1rio mudar no front o caminho que a requisi\u00e7\u00e3o \u00e9 feita.</p> <pre><code>export const environment = {\n    SERVIDOR: \"https://frontend.llw\"\n};\n</code></pre> <p>Ap\u00f3s isso, buildamos o front e fizemos deploy dele novamente, e agora j\u00e1 ser\u00e1 poss\u00edvel fazer requisi\u00e7\u00f5es ao back utilizando HTTPS tamb\u00e9m.</p>"},{"location":"#6-configurando-o-mariadb-para-usar-tls","title":"6 Configurando o mariadb para usar TLS","text":""},{"location":"#61-modificando-o-arquivo-de-configuracao-do-mariadb-etcmycnfdmariadb-servercnf","title":"6.1 Modificando o arquivo de configura\u00e7\u00e3o do mariadb (/etc/my.cnf.d/mariadb-server.cnf)","text":"<pre><code>require_secure_transport = on\nssl-cert = /etc/ssl/certs/llw.crt\nssl-key = /etc/ssl/private/llw.key\nssl-ca = /etc/ssl/certs/llw-ca.crt\ntls_version = TLSv1.2,TLSv1.3\nssl-cipher = ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:DHE-RSA-CHACHA20-POLY1305\n</code></pre>"},{"location":"#62-movendo-os-certificados-para-as-pastas-certas","title":"6.2 Movendo os certificados para as pastas certas","text":"<pre><code>cp llw.crt /etc/ssl/certs/llw.crt\ncp llw.key /etc/ssl/private/llw.key\ncp llw-ca.crt /etc/ssl/certs/llw.crt\n</code></pre>"},{"location":"#63-modificando-a-conexao-com-o-bd-do-back","title":"6.3 Modificando a conex\u00e3o com o BD do back","text":"<p>Teremos que modificar o jeito que o back faz conex\u00e3o com o banco, como n\u00e3o \u00e9 http n\u00e3o \u00e9 t\u00e3o simples como mudar pra https, ent\u00e3o devemos adicionar alguns extras no url.</p> <pre><code>spring.datasource.url=jdbc:mysql://database.llw:3306/adv?useSSL=true&amp;requireSSL=true&amp;verifyServerCertificate=true\n</code></pre>"},{"location":"#64-adicionando-o-crt-no-truststore-do-java","title":"6.4 Adicionando o crt no truststore do java","text":"<p>Para que o spring confie no certificado que o banco apresenta ele ter\u00e1 que estar presente no arquivo truststore do java que estamos utilizando.</p> <pre><code>keytool -importcert -alias llw -file llw.crt -keystore /usr/lib/jvm/java-17-openjdk/lib/security/cacerts -storepass changeit\nkeytool -importcert -alias llw -file llw-ca.crt -keystore /usr/lib/jvm/java-17-openjdk/lib/security/cacerts -storepass changeit\n</code></pre> <p>Ele perguntar\u00e1 se deseja mesmo confiar neste certificado, responderemos \"yes\", e ele confirmar\u00e1 com \"Certificate was added to keystore\"</p>"},{"location":"enunciado/","title":"Configura\u00e7\u00e3o de Ambiente Distribu\u00eddo com Alta Disponibilidade, Seguran\u00e7a e Autentica\u00e7\u00e3o Unificada","text":""},{"location":"enunciado/#integrantes-do-grupo","title":"Integrantes do grupo","text":"<ul> <li>Fabiano Da Silva Santos  </li> <li>Felipe Jacinto Camilo  </li> <li>Pedro Henrique Alves Dos Santos  </li> <li>Pedro Lucas De Oliveira Soares  </li> </ul>"},{"location":"enunciado/#professores","title":"Professores","text":"<ul> <li>Wilson Varaschin</li> <li>La\u00e9rcio Bubiak da Cruz</li> </ul>"},{"location":"keycloak/","title":"Keycloak","text":"<p>Essa documenta\u00e7\u00e3o vai passar pelos passos necess\u00e1rios para implementa\u00e7\u00e3o da autentica\u00e7\u00e3o com keycloak.</p>"},{"location":"keycloak/#adaptando-api-para-rodar-com-keycloak-no-angular","title":"Adaptando API para rodar com keycloak no angular","text":""},{"location":"keycloak/#instalando-o-pacote-no-angular","title":"Instalando o pacote (no angular)","text":"<pre><code>npm install keycloak-js\n</code></pre>"},{"location":"keycloak/#iniciando-o-keycloak-junto-com-o-angular-maints","title":"Iniciando o keycloak junto com o angular, main.ts","text":"<pre><code>export function kcFactory(kcService: KeycloakService) {\n  return () =&gt; kcService.init();\n}\n\nbootstrapApplication(AppComponent, {\n  providers: [\n    KeycloakService,\n    {\n      provide: APP_INITIALIZER,\n      useFactory: kcFactory,\n      deps: [KeycloakService],\n      multi: true,\n    },\n    provideRouter(routes),\n    provideHttpClient(withInterceptors([authInterceptor])),\n  ],\n});\n</code></pre>"},{"location":"keycloak/#service-do-keycloak","title":"Service do keycloak","text":"<pre><code>export class KeycloakService {\n  private keycloak: Keycloak | undefined;\n  private profile: UserProfile | undefined;\n\n  get getKeycloak() {\n    if (!this.keycloak) {\n      this.keycloak = new Keycloak({\n        url: 'https://frontend.llw/',\n        realm: 'main_realm',\n        clientId: 'lionlaw',\n      });\n    }\n    return this.keycloak;\n  }\n\n  get getProfile() {\n    return this.profile;\n  }\n\n  getRoute(path: string): string {\n    if (this.profile &amp;&amp; this.profile.role === 'ADMIN') {\n      return `/admin/${path}`;\n    } else {\n      return `/user/${path}`;\n    }\n  }\n\n  async init() {\n  console.log('Autenticando Usu\u00e1rio');\n  const authenticated = await this.getKeycloak?.init({\n    onLoad: 'login-required',\n  });\n\n  if (authenticated) {\n    console.log('Usu\u00e1rio autenticado');\n    this.profile = (await this.keycloak?.loadUserProfile() as UserProfile);\n    this.profile.token = this.keycloak?.token;\n\n    const clientRoles = this.keycloak?.resourceAccess?.['llw']?.roles;\n\n    if (clientRoles?.includes('ADMIN')) {\n      this.profile.role = 'ADMIN';\n    } else {\n      this.profile.role = 'USER';\n    }\n  }\n}\n\n  login() {\n    return this.keycloak?.login();\n  }\n\n  logout() {\n    return this.keycloak?.logout();\n  }\n}\n</code></pre>"},{"location":"keycloak/#http-interceptor","title":"HTTP interceptor","text":"<pre><code>export const authInterceptor: HttpInterceptorFn = (req, next) =&gt; {\n  const token = inject(KeycloakService).getKeycloak?.token;\n\n  if (token) {\n    req = req.clone({\n      setHeaders: {\n        Authorization: `Bearer ${token}`,\n      },\n    });\n  }\n\n  return next(req);\n};\n</code></pre>"},{"location":"keycloak/#auth-guard","title":"Auth Guard","text":"<pre><code>export const authGuard: CanActivateFn = () =&gt; {\n  const keycloak = inject(KeycloakService).getKeycloak;\n  return keycloak?.authenticated ?? false;\n};\n</code></pre>"},{"location":"keycloak/#user-profile","title":"User profile","text":"<pre><code>export interface UserProfile {\n  id?: string;\n  username?: string;\n  email?: string;\n  firstName?: string;\n  lastName?: string;\n  token?: string;\n  role?: string;\n}\n</code></pre>"},{"location":"keycloak/#adaptacoes-para-rodar-com-keycloak-spring-boot","title":"Adapta\u00e7\u00f5es para rodar com Keycloak Spring boot","text":""},{"location":"keycloak/#securityconfig","title":"SecurityConfig","text":"<pre><code>@Configuration\n@EnableWebSecurity\npublic class SecurityConfig {\n\n  @Bean\n  public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\n    http\n      .csrf(AbstractHttpConfigurer::disable)\n      .cors(AbstractHttpConfigurer::disable)\n      .authorizeHttpRequests((requests) -&gt; requests\n        .anyRequest().authenticated()\n      )\n      .oauth2ResourceServer(oauth2 -&gt; oauth2.jwt())\n      .sessionManagement(session -&gt; session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));\n\n    return http.build();\n  }\n\n  @Bean\n  public FilterRegistrationBean&lt;CorsFilter&gt; corsFilter() {\n    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n    CorsConfiguration config = new CorsConfiguration();\n    config.setAllowCredentials(true);\n    config.setAllowedOriginPatterns(Arrays.asList(\"*\"));\n    config.setAllowedHeaders(Arrays.asList(HttpHeaders.AUTHORIZATION, HttpHeaders.CONTENT_TYPE, HttpHeaders.ACCEPT));\n    config.setAllowedMethods(Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name(), HttpMethod.PUT.name(), HttpMethod.DELETE.name()));\n    config.setMaxAge(3600L);\n    source.registerCorsConfiguration(\"/**\", config);\n    FilterRegistrationBean&lt;CorsFilter&gt; bean = new FilterRegistrationBean&lt;&gt;(new CorsFilter(source));\n    bean.setOrder(-102);\n    return bean;\n  }\n}\n</code></pre>"},{"location":"keycloak/#aplication-properties","title":"Aplication Properties","text":"<pre><code>spring.security.oauth2.resourceserver.jwt.issuer-uri=https://frontend.llw/realms/main_realm\n</code></pre> <p>Nosso keycloak est\u00e1 no back mas ele ainda tem que mandar pro front que \u00e9 o ISSUER aceito no token</p>"},{"location":"keycloak/#adaptacoes-nas-vm","title":"Adapta\u00e7\u00f5es nas VM","text":""},{"location":"keycloak/#adaptacao-no-proxy-reverso-front","title":"Adapta\u00e7\u00e3o no proxy reverso (front)","text":"<pre><code>location /realms {\n        proxy_pass https://backend.llw:8443;\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_pass_request_headers on;\n        proxy_pass_request_body on;\n    }\n\n    location /resources {\n        proxy_pass https://backend.llw:8443/resources;\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_pass_request_headers on;\n        proxy_pass_request_body on;\n    }\n</code></pre>"},{"location":"keycloak/#instalando-docker-backend","title":"Instalando docker (backend)","text":"<pre><code>apk add docker docker-compose\n</code></pre>"},{"location":"keycloak/#iniciando-ao-ligar-vm","title":"Iniciando ao ligar VM","text":"<pre><code>rc-update add docker default\n</code></pre>"},{"location":"keycloak/#docker","title":"DOCKER","text":"<pre><code>services:\n  postgres:\n    image: postgres:16\n    container_name: keycloak_postgres\n    environment:\n      POSTGRES_DB: keycloak\n      POSTGRES_USER: keycloak\n      POSTGRES_PASSWORD: keycloak\n    volumes:\n      - postgres_data:/var/lib/postgresql/data\n    restart: unless-stopped\n\n  keycloak:\n    image: quay.io/keycloak/keycloak:latest\n    container_name: keycloak\n    command: start --https-port=8443\n    ports:\n      - \"8443:8443\"\n    environment:\n      KEYCLOAK_ADMIN: admin\n      KEYCLOAK_ADMIN_PASSWORD: admin\n      KC_DB: postgres\n      KC_DB_URL: jdbc:postgresql://postgres:5432/keycloak\n      KC_DB_USERNAME: keycloak\n      KC_DB_PASSWORD: keycloak\n      KC_HOSTNAME_STRICT: \"false\"\n\n      KC_HTTPS_CERTIFICATE_FILE: /certs/llw.crt\n      KC_HTTPS_CERTIFICATE_KEY_FILE: /certs/llw.key\n\n    volumes:\n      - keycloak_data:/opt/keycloak/data\n      - ./llw.crt:/certs/llw.crt:ro\n      - ./llw.key:/certs/llw.key:ro\n    depends_on:\n      - postgres\n    restart: unless-stopped\n\nvolumes:\n  postgres_data:\n  keycloak_data:\n</code></pre>"},{"location":"keycloak/#rodando-o-container","title":"Rodando o container","text":"<pre><code>docker-compose up -d\n</code></pre>"},{"location":"keycloak/#adaptando-iptables-front","title":"Adaptando iptables (front)","text":"<pre><code>iptables -A INPUT -p tcp --dport 443 -j ACCEPT\n</code></pre> <p>Removemos as permiss\u00f5es de 8080 que era a conex\u00e3o antiga e liberamos 443, que \u00e9 a padr\u00e3o para https.</p>"},{"location":"keycloak/#adaptando-iptables-back","title":"Adaptando iptables (back)","text":"<pre><code>iptables -A INPUT -p tcp -s frontend.llw -d backend.llw --dport 443 -j ACCEPT\niptables -A INPUT -p tcp -s frontend.llw -d backend.llw --dport 8443 -j ACCEPT\n</code></pre> <p>No back tambem, mas agora recebemos conex\u00f5es 443 apenas do front e 8443 para o keycloak.</p>"},{"location":"mensal2/","title":"Implementa\u00e7\u00e3o de Infraestrutura Segura e Automatizada","text":""},{"location":"mensal2/#1-instalacao-e-configuracao-do-alpine-linux-no-virtualbox-vm-base","title":"1. Instala\u00e7\u00e3o e Configura\u00e7\u00e3o do Alpine Linux no VirtualBox (VM Base)","text":"<p>Este documento explica passo a passo a configura\u00e7\u00e3o realizada na VM Base, e serve como template para as m\u00e1quinas virtuais criadas posteriormente, com a possibilidade de clonar essa base, evitamos a necessidade de refazer configura\u00e7\u00f5es que s\u00e3o comuns a todas elas. Permitindo que o foco fique em configurar apenas o necess\u00e1rio para que determinada m\u00e1quina virtual cumpra o objetivo para o qual foi criada, seja Frontend, Backend, Database ou qualquer possibilidade que possa surgir futuramente. </p>"},{"location":"mensal2/#11-download-dos-recursos-necessarios","title":"1.1 Download dos Recursos Necess\u00e1rios","text":"<p>Come\u00e7amos com o download e instala\u00e7\u00e3o de um hypervisor, um software que permite executar v\u00e1rias m\u00e1quinas virtuais em uma \u00fanica m\u00e1quina f\u00edsica. A escolha para esse projeto foi o Oracle VirtualBox.</p> <p>Em seguida  fizemos o download da  ISO do Alpine Linux, em sua vers\u00e3o virtual, que dispensa interface gr\u00e1fica, contando apenas com o Bash, uma interface de linha de comando (CLI) usada para interpretar comandos.</p>"},{"location":"mensal2/#12-criacao-da-maquina-virtual","title":"1.2 Cria\u00e7\u00e3o da M\u00e1quina Virtual","text":"<p>Ap\u00f3s instalar o VirtualBox e baixar a ISO do Alpine, criamos a m\u00e1quina m\u00e1quina virtual (VM) com as seguintes especifica\u00e7\u00f5es:</p> <ul> <li>CPU: 1 core  </li> <li>RAM: 512 MB  </li> <li>Disco: 20 GB  </li> <li>ISO de Boot: Alpine Linux (modo virtual)</li> </ul> <p></p>"},{"location":"mensal2/#13-ajustes-iniciais-da-vm","title":"1.3 Ajustes Iniciais da VM","text":""},{"location":"mensal2/#14-configuracao-de-rede","title":"1.4 Configura\u00e7\u00e3o de Rede","text":"<p>Adicionamos uma nova interface de rede em modo Bridge, para permitir que a VM se conecte a outros dispositivos na mesma rede, como se fosse um dispositivo f\u00edsico separado.</p> <p></p>"},{"location":"mensal2/#15-boot-e-setup-do-alpine-linux","title":"1.5 Boot e Setup do Alpine Linux","text":"<p>Ao iniciar pela primeira vez, utilizamos o login com root sem informar senha:</p> <ul> <li>Login: <code>root</code> </li> <li>Senha: (vazio)</li> </ul> <p>E o seguinte comando para iniciar a instala\u00e7\u00e3o do Alpine Linux:</p> <pre><code>setup-alpine\n</code></pre>"},{"location":"mensal2/#16-configuracoes-do-setup-do-alpine-linux","title":"1.6 Configura\u00e7\u00f5es do Setup do Alpine Linux","text":"<p>Essas foram nossas escolhas para configurar a VM base, mas elas podem ser alteradas mais tarde dependendo da necessidade de cada tipo de VM.</p> <ul> <li>Layout de Teclado: <code>br-br</code> </li> <li>Hostname: <code>localhost</code> </li> <li>Interfaces de Rede: <code>eth0 (NAT)</code>, <code>eth1 (Bridge)</code> </li> <li>Endere\u00e7o IP: <code>DHCP</code> </li> <li>Configura\u00e7\u00e3o Manual da Interface: <code>n</code> </li> <li>Senha do usu\u00e1rio root: <code>root</code> </li> <li>Fuso Hor\u00e1rio: <code>America/Sao_Paulo</code> </li> <li>Proxy: <code>none</code> </li> <li>NTP: <code>chrony</code> </li> <li>Reposit\u00f3rio (Mirror): <code>1</code> </li> <li>Criar um usu\u00e1rio comum: <code>n</code> </li> <li>Servidor SSH: <code>openssh</code> </li> <li>Permitir login root via SSH: <code>prohibit-password</code> </li> <li>Chave SSH para root: <code>none</code> </li> <li>Disco selecionado: <code>sda</code> </li> <li>Modo de uso do disco: <code>sys</code> </li> <li>Apagar dados do disco: <code>y</code></li> </ul>"},{"location":"mensal2/#17-finalizando-a-instalacao","title":"1.7 Finalizando a Instala\u00e7\u00e3o","text":"<p>Ap\u00f3s concluir o processo de instala\u00e7\u00e3o, desligamos a m\u00e1quina virtual:</p> <pre><code>poweroff\n</code></pre> <p>Removemos o dispositivo que cont\u00e9m ISO do Alpine, pois o sistema j\u00e1 foi instalado no disco r\u00edgido.</p>"},{"location":"mensal2/#18-gerenciamento-de-pacotes","title":"1.8 Gerenciamento de Pacotes","text":""},{"location":"mensal2/#181-habilitando-repositorios-da-comunidade","title":"1.8.1 Habilitando Reposit\u00f3rios da Comunidade","text":"<p>Abrimos o arquivo repositories em modo de edi\u00e7\u00e3o:</p> <pre><code>vi /etc/apk/repositories\n</code></pre> <p>Removemos o <code>#</code> na frente do link para habilitar o reposit\u00f3rio <code>community</code>, que possui pacotes utilizados em nosso projeto.</p> <pre><code>http://dl-cdn.alpinelinux.org/alpine/v3.19/community\n</code></pre>"},{"location":"mensal2/#182-atualizando-o-sistema","title":"1.8.2 Atualizando o Sistema","text":"<p>Executamos os comandos para atualiza\u00e7\u00e3o dos pacotes: </p> <p>O primeiro lista os pacotes dispon\u00edveis nos reposit\u00f3rios:</p> <pre><code>apk update\n</code></pre> <p>O segundo atualiza os pacotes instalados em caso de existirem atualiza\u00e7\u00f5es:</p> <pre><code>apk upgrade\n</code></pre>"},{"location":"mensal2/#183-instalando-um-editor-de-texto-alternativo","title":"1.8.3 Instalando um Editor de Texto Alternativo","text":"<p>Parte do nosso grupo utilizou o editor de texto nano e parte utilizou o vim, para essa documenta\u00e7\u00e3o os exemplos ser\u00e3o com vim: </p> <pre><code>apk add vim\n</code></pre>"},{"location":"mensal2/#19-melhorando-a-integracao-com-o-host","title":"1.9 Melhorando a integra\u00e7\u00e3o com o host","text":"<p>Instalamos o  VirtualBox Guest Additions para melhorar a integra\u00e7\u00e3o com o host:</p> <pre><code>apk add virtualbox-guest-additions\n</code></pre> <p>Em seguida iniciamos o servi\u00e7o e configuramos para que inicie automaticamente:</p> <pre><code>rc-service virtualbox-guest-additions start\nrc-update add virtualbox-guest-additions\n</code></pre>"},{"location":"mensal2/#110-configurando-acesso-ssh","title":"1.10 Configurando Acesso SSH","text":"<p>Editamos o arquivo de configura\u00e7\u00e3o do SSH para permitir o acesso por senha temporariamente:</p> <pre><code>vim /etc/ssh/sshd_config\n</code></pre> <p>Alteramos duas linhas para permitir conex\u00e3o ssh com root e para permitir login com senha:</p> <pre><code>PermitRootLogin yes\nPasswordAuthentication yes\n</code></pre> <p>E reiniciamos o servi\u00e7o para confirmar as altera\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre>"},{"location":"mensal2/#111-acesso-via-chave-ssh","title":"1.11 Acesso via Chave SSH","text":""},{"location":"mensal2/#1111-gerando-chave-no-host","title":"1.11.1 Gerando Chave no Host","text":"<p>No powershell do Windows geramos um par de chaves:</p> <pre><code>ssh-keygen -t rsa -b 4096 -f id_rsa\n</code></pre> <p>No momento de gerar as chaves deixamos o campo de senha vazio.</p>"},{"location":"mensal2/#1112-preparando-a-vm-para-receber-a-chave","title":"1.11.2 Preparando a VM para Receber a Chave","text":"<p>Na VM criamos o diret\u00f3rio .ssh:</p> <pre><code>mkdir /root/.ssh\n</code></pre> <p>E no Windows enviamos a chave p\u00fablica para a pasta .ssh da VM via scp:</p> <pre><code>scp .ssh/id_rsa.pub root@192.168.1.108:/root/.ssh/authorized_keys\n</code></pre> <p>Ajustamos as permiss\u00f5es do arquivo enviado:</p> <pre><code>chmod 600 /root/.ssh/authorized_keys\n</code></pre> <p>e em seguida testamos a conex\u00e3o:</p> <pre><code>ssh root@192.168.1.108\n</code></pre>"},{"location":"mensal2/#1113-desabilitando-acesso-por-senha","title":"1.11.3 Desabilitando Acesso por Senha","text":"<p>Editamos novamente o <code>sshd_config</code>, dessa vez para impedir o acesso por senha:</p> <pre><code>PasswordAuthentication no\n</code></pre> <p>E reiniciamos o servi\u00e7o para aplicar as configura\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre> <p>A partir deste ponto, o acesso \u00e0 VM ser\u00e1 feito exclusivamente via chave SSH e sem utiliza\u00e7\u00e3o de senha.</p>"},{"location":"mensal2/#2-configuracao-da-vm-frontend","title":"2. Configura\u00e7\u00e3o da VM Frontend","text":"<p>A VM Frontend \u00e9 respons\u00e1vel por hospedar a interface do sistema utilizando o servidor web nginx, e tamb\u00e9m atua como servidor de backups, armazenando os arquivos de backup de todas as outras VMs, incluindo ela mesma. Por esse motivo, ela possui um arquivo authorized_kyes com a chave p\u00fablica rsa de cada uma das outras m\u00e1quinas virtuais em seu usu\u00e1rio backup_sys, permitindo que os arquivos de backup sejam recebidos via scp.</p>"},{"location":"mensal2/#21-clonando-a-vm-base","title":"2.1 Clonando a VM Base","text":"<p>Come\u00e7amos fazendo o clone do tipo completo da VM base, que foi criada previamente.  </p> <p></p>"},{"location":"mensal2/#211-configuracao-da-interface-em-modo-bridge","title":"2.1.1 Configura\u00e7\u00e3o da Interface em modo bridge","text":"<p>Para cada VM que clonamos foi necess\u00e1rio atribuir um IP pr\u00f3prio editando o arquivo de interfaces:</p> <pre><code>vim /etc/network/interfaces\n</code></pre> <p>Como a nossa interface em modo bridge \u00e9 o adaptador 2, ela fica identificada como eth1:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 192.168.0.3\n    netmask 255.255.255.0\n</code></pre> <p>Ap\u00f3s salvar o arquivo reiniciamos o servi\u00e7o:</p> <pre><code>rc-service networking restart\n</code></pre>"},{"location":"mensal2/#22-alterando-o-hostname","title":"2.2 Alterando o Hostname","text":"<p>Para diferenciar a VM Frontend das demais, alteramos seu hostname para frontend, editando o arquivo de hostname:</p> <pre><code>vim /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"mensal2/#23-configurando-resolucao-de-nome-para-os-ips","title":"2.3 Configurando resolu\u00e7\u00e3o de nome para  os IPs","text":"<p>Para nosso projeto utilizamos o nome <code>backend.llw</code> para o backend e \u00e9 atrav\u00e9s dele que o frontend realiza requisi\u00e7\u00f5es, ent\u00e3o foi necess\u00e1rio alterar o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do backend com seu respectivo nome:</p> <pre><code>\"192.168.0.1\" backend.llw\n</code></pre>"},{"location":"mensal2/#24-arquivo-hosts-no-windows","title":"2.4 Arquivo Hosts no Windows","text":"<p>Editamos o arquivo hosts do Windows com permiss\u00f5es de administrador que fica localizado no seguinte diret\u00f3rio:</p> <pre><code>C:\\Windows\\System32\\drivers\\etc\\hosts\n</code></pre> <p>E informamos o IP do backend com seu respectivo nome assim como fizemos na VM:</p> <pre><code>192.168.1.106 backend.llw\n</code></pre>"},{"location":"mensal2/#25-instalando-o-nginx","title":"2.5 Instalando o Nginx","text":"<p>Instalamos o servidor web nginx:</p> <pre><code>apk add nginx\n</code></pre> <p>Iniciamos o servi\u00e7o e configuramos para que inicie automaticamente:</p> <pre><code>rc-service nginx start\nrc-update add nginx\n</code></pre>"},{"location":"mensal2/#26-configurando-o-nginx","title":"2.6 Configurando o Nginx","text":"<p>Editamos o arquivo de configura\u00e7\u00e3o do nginx:</p> <pre><code>vim /etc/nginx/http.d/default.conf\n</code></pre> <p>Adicionamos logs de acesso e de erros no arquivo:</p> <pre><code>access_log /var/log/nginx/frontend_access.log;\nerror_log /var/log/nginx/frontend_error.log;\n</code></pre> <p>Indicamos o caminho onde os nossos arquivos est\u00e1ticos de frontend est\u00e3o localizados:</p> <pre><code>location / {\n    root /opt/frontend;\n    index index.html;\n    try_files $uri $uri/ /index.html;\n}\n</code></pre> <p>E recarregamos o nginx para confirmar as altera\u00e7\u00f5es:</p> <pre><code>nginx -s reload\n</code></pre>"},{"location":"mensal2/#27-buildando-o-frontend","title":"2.7 Buildando o Frontend","text":"<p>No Windows antes de fazer o build do frontend, foi necess\u00e1rio configurar corretamente o endere\u00e7o IP da API Backend. </p> <p>Editamos o arquivo <code>environment.server.ts</code> do angular:</p> <pre><code>export const environment = {\n  production: true,\n  apiUrl: 'http://backend.llw:8080'\n};\n</code></pre> <p>Realizamos o build e compactamos os arquivos em um .zip, para s\u00f3 ent\u00e3o realizar o envio via scp para a VM no diret\u00f3rio que criamos em <code>/opt/frontend</code></p> <pre><code>scp site.zip root@192.168.1.105:/opt/frontend/\n</code></pre> <p>J\u00e1 na VM descompactamos o arquivo usando o comando:</p> <pre><code>unzip site.zip\n</code></pre> <p>Com esse passo j\u00e1 foi poss\u00edvel visualizar a tela inicial do projeto utilizando o ip da VM Frontend no navegador.</p> <p></p>"},{"location":"mensal2/#28-preparando-o-ambiente-para-o-backup","title":"2.8 Preparando o ambiente para o backup","text":"<p>Criamos um diret\u00f3rio para armazenar os backups:</p> <pre><code>mkdir /opt/backup/\n</code></pre> <p>Em seguida diret\u00f3rios que separam os backups buscando organizar os arquivos:</p> <pre><code>mkdir /opt/backup/frontend/\nmkdir /opt/backup/backend/\nmkdir /opt/backup/database/\n</code></pre> <p>E por fim adicionamos um novo usu\u00e1rio chamado <code>backup_sys</code> definindo a home dele dentro do diret\u00f3rio de backups:</p> <pre><code>adduser -h /opt/backup backup_sys\n</code></pre>"},{"location":"mensal2/#29-recebendo-as-chaves-rsa-das-outras-vms","title":"2.9 Recebendo as chaves RSA das outras VM's:","text":""},{"location":"mensal2/#291-criando-o-par-de-chaves","title":"2.9.1 Criando o par de chaves","text":"<p>Na VM Backend e Database criamos as chaves RSA:</p> <pre><code>ssh-keygen -t rsa -b 4096 -f id_rsa\n</code></pre> <p>E na VM Frontend editamos o arquivo de configura\u00e7\u00e3o do ssh: </p> <pre><code>vim /etc/ssh/sshd_config\n</code></pre> <p>Permitimos o login com senha provisoriamente, apenas para conseguirmos enviar a chave p\u00fablica:</p> <pre><code>PasswordAuthentication yes\n</code></pre> <p>Reiniciamos o servi\u00e7o para aplicar as configura\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre>"},{"location":"mensal2/#292-enviando-a-chave-publica-para-backup_sys","title":"2.9.2 Enviando a chave p\u00fablica para backup_sys","text":"<p>Enviamos a chave p\u00fablica da VM Backend para o backup_sys modificando o nome para <code>authorized_keys</code>:</p> <pre><code>scp id_rsa.pub backup_sys@frontend.llw:/opt/backup/.ssh/authorized_keys\n</code></pre> <p>Em seguida enviamos a chave p\u00fablica da VM Database para o backup_sys, mas sem dar um nome diferente para a chave:</p> <pre><code>scp id_rsa.pub backup_sys@frontend.llw:/opt/backup/.ssh/\n</code></pre> <p>Na VM Frontend, utilizamos o comando cat para adicionar a segunda chave p\u00fablica no final do arquivo authorized_keys:</p> <pre><code>cat /opt/backup/.ssh/id_rsa.pub &gt;&gt; /opt/backup/.ssh/authorized_keys\n</code></pre> <p>Apagamos o arquivo id_rsa.pub que ficou sobrando:</p> <pre><code>rm /opt/backup/.ssh/id_rsa.pub\n</code></pre> <p>Modificamos as permiss\u00f5es da chave:</p> <pre><code>chmod 600 /opt/backup/.ssh/authorized_keys\n</code></pre> <p>E alteramos o propriet\u00e1rio dessa pasta .ssh localizada em <code>/opt/backup</code>:</p> <pre><code>chown -R backup_sys:backup_sys /opt/backup/.ssh\n</code></pre>"},{"location":"mensal2/#293-retirando-a-autenticacao-por-senha","title":"2.9.3 Retirando a autentica\u00e7\u00e3o por senha","text":"<p>Por fim editamos novamente o <code>sshd_config</code>, dessa vez para impedir o acesso por senha:</p> <pre><code>PasswordAuthentication no\n</code></pre> <p>E reiniciamos o servi\u00e7o para aplicar as configura\u00e7\u00f5es uma \u00faltima vez:</p> <pre><code>rc-service sshd restart\n</code></pre>"},{"location":"mensal2/#210-configurando-o-script-de-backup-local","title":"2.10 Configurando o script de backup local","text":"<p>Criamos o arquivo em <code>/root/</code>:</p> <pre><code>vim /root/backup_front\n</code></pre> <p>E preenchemos da seguinte forma: </p> <pre><code>#!/bin/sh\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\ntemp_dir=\"/tmp/backup_front_$timestamp\"\nfront_dir=\"$temp_dir/front\"\nfront_end=\"/opt/frontend\"\nauthorized_keys=\"/root/.ssh/authorized_keys\"\ntar_file=\"/opt/backup/frontend/backup_front_$timestamp.tar.gz\"\n\necho \"Criando diret\u00f3rios tempor\u00e1rios, Data: $timestamp\"\nmkdir -p \"$front_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Copiando arquivos do frontend, Data: $timestamp\"\ncp -r \"$front_end/\"* \"$front_dir/\" || { echo \"Erro ao copiar arquivos do frontend, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Copiando authorized_keys, Data: $timestamp\"\ncp \"$authorized_keys\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Compactando tudo, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"-&gt; Backup criado com sucesso, Data: $timestamp \"\n\nrm -rf \"$temp_dir\"\nexit 0\n</code></pre> <p>E por fim tornamos o arquivo execut\u00e1vel:</p> <pre><code>chmod +x /root/backup_front\n</code></pre>"},{"location":"mensal2/#211-agendamento-de-script-backup-com-crontab","title":"2.11 Agendamento de Script Backup com Crontab","text":"<p>Editamos o arquivo de agendamento padr\u00e3o do Linux Alpine:</p> <pre><code>vim /etc/crontabs/root\n</code></pre> <p>Adicionamos essa linha ao final do arquivo para rodar o script de backup automaticamente a cada 3 horas:</p> <pre><code>0 */3 * * * /root/backup_front 1&gt;&gt; /var/log/backup_front.log 2&gt;&gt; /var/log/backup_front_error.log\n</code></pre> <p>Utilizamos o comando <code>cat</code> em <code>messages</code> depois do tempo proposto: </p> <pre><code>cat /var/log/messages | grep backup \n</code></pre> <p></p> <p>Resultado do log do Cron</p>"},{"location":"mensal2/#3-configuracao-da-vm-backend","title":"3. Configura\u00e7\u00e3o da VM Backend","text":"<p>A VM Backend \u00e9 respons\u00e1vel por executar a nossa API utilizando o Java 17, ela possui um usu\u00e1rio dedicado backend que executar\u00e1 o processo, e tamb\u00e9m um script de inicializa\u00e7\u00e3o que executar\u00e1 automaticamente ao ligar a m\u00e1quina virtual.</p>"},{"location":"mensal2/#31-clonando-a-vm-base","title":"3.1 Clonando a VM Base","text":"<p>Come\u00e7amos fazendo o clone do tipo completo da VM base, que foi criada previamente.  </p> <p></p>"},{"location":"mensal2/#311-configuracao-da-interface-em-modo-bridge","title":"3.1.1 Configura\u00e7\u00e3o da Interface em modo bridge","text":"<p>Para cada VM que clonamos foi necess\u00e1rio atribuir um IP pr\u00f3prio editando o arquivo de interfaces:</p> <pre><code>vim /etc/network/interfaces\n</code></pre> <p>Como a nossa interface em modo bridge \u00e9 o adaptador 2, ela fica identificada como eth1:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 192.168.0.1\n    netmask 255.255.255.0\n</code></pre> <p>Ap\u00f3s salvar o arquivo reiniciamos o servi\u00e7o:</p> <pre><code>rc-service networking restart\n</code></pre>"},{"location":"mensal2/#32-alterando-o-hostname","title":"3.2 Alterando o Hostname","text":"<p>Para diferenciar a VM Frontend das demais, alteramos seu hostname para frontend, editando o arquivo de hostname:</p> <pre><code>vim /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"mensal2/#33-configurando-resolucao-de-nome-para-os-ips","title":"3.3 Configurando resolu\u00e7\u00e3o de nome para  os IPs","text":"<p>Para nosso projeto utilizamos o nome <code>database.llw</code> para o banco de dados e \u00e9 atrav\u00e9s dele que o backend se comunica com a VM de database, ent\u00e3o foi necess\u00e1rio alterar o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP da database com seu respectivo nome:</p> <pre><code>192.168.0.2 database.llw\n</code></pre>"},{"location":"mensal2/#34-instalando-o-java-17","title":"3.4 Instalando o Java 17","text":"<p>Instalamos o Java 17 com o comando:</p> <pre><code>apk add openjdk17\n</code></pre>"},{"location":"mensal2/#35-buildando-o-projeto","title":"3.5 Buildando o Projeto","text":"<p>No Windows antes de fazer a build do backend, foi necess\u00e1rio configurar corretamente o endere\u00e7o IP da VM Database junto com o usu\u00e1rio e senha do banco de dados.</p> <p>Editamos o arquivo application.properties:</p> <pre><code>spring.datasource.url=jdbc:mysql://database.llw:3306/adv\nspring.datasource.username=advocacia\nspring.datasource.password=PePeFaFe!05\n</code></pre> <p>Depois enviamos o arquivo jar por scp para o diret\u00f3rio <code>/opt/backend</code> que criamos na VM:</p> <pre><code>scp backend.jar root@192.168.105:/opt/backend/\n</code></pre> <p>Ap\u00f3s esse passo executamos o comando:</p> <pre><code>java -jar backend.jar\n</code></pre> <p></p> <p></p> <p>Como tudo foi configurado corretamente, a aplica\u00e7\u00e3o iniciou.</p>"},{"location":"mensal2/#36-criando-o-script-para-rodar-a-api-automaticamente","title":"3.6 Criando o script para rodar a API automaticamente","text":"<p>Adicionamos um novo usu\u00e1rio chamado <code>backend</code> que \u00e9 o respons\u00e1vel por rodar a aplica\u00e7\u00e3o e definimos a home dele em <code>/opt/backend</code>:</p> <pre><code>adduser -h /opt/backend backend\n</code></pre> <p>Em seguida dentro do diret\u00f3rio <code>/etc/init.d /</code> abrimos um novo arquivo em branco chamado backend:</p> <pre><code>vim  /etc/init.d/backend\n</code></pre> <p>Preenchemos ele com o seguinte script:</p> <pre><code>#!/sbin/openrc-run\ndescription=\"Lionlaw\"\njava=\"/usr/bin/java\"\narquivo=\"/opt/backend/backend.jar\"\npidfile=\"/opt/backend/lionlaw.pid\"\noutput_log=\"/opt/backend/backend.out\"\nusuario=\"backend\"\n\ndepend() {\n    need net\n    after local\n}\nstart_pre() {\n    echo \"Iniciando Spring...\"\n}\nstart() {\n    cd /opt/backend || exit 1\n    su -s /bin/sh -c \"nohup $java -jar $arquivo &gt; $output_log 2&gt;&amp;1 &amp; echo \\$! &gt; $pidfile\" $usuario\n    echo \"Aguardando LionLaw Iniciar...\"\n    for i in $(seq 1 60); do\n        if netstat -tlnp 2&gt;/dev/null | grep -q \":8080 \"; then\n            echo \"Backend LionLaw iniciado!\"\n            return 0\n        fi\n        sleep 1\n    done\n    echo \"Falha ao iniciar LionLaw.\"\n    return 1\n}\nstop() {\n    echo \"Parando servi\u00e7o...\"\n    if [ -f \"$pidfile\" ]; then\n        kill -9 \"$(cat $pidfile)\" &amp;&amp; rm -f \"$pidfile\"\n        echo \"LionLaw parado.\"\n    else\n        echo \"Nenhum servi\u00e7o rodando na porta 8080.\"\n    fi\n}\n</code></pre> <p>Tornamos o arquivo execut\u00e1vel:</p> <pre><code>chmod +x /etc/init.d/backend\n</code></pre> <p>Iniciamos a aplica\u00e7\u00e3o e configuramos para que inicie automaticamente:</p> <pre><code>service backend start\nrc-update add backend \n</code></pre> <p>Com essa configura\u00e7\u00e3o a aplica\u00e7\u00e3o executa automaticamente ao ligar a m\u00e1quina virtual </p>"},{"location":"mensal2/#37-configurando-o-script-de-backup","title":"3.7 Configurando o script de backup","text":"<p>Criamos o arquivo em <code>/root/</code>:</p> <pre><code>vim /root/backup_backend\n</code></pre> <p>E preenchemos da seguinte forma: </p> <pre><code>#!/bin/ash\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\ntemp_dir=\"/tmp/backup_backend_$timestamp\"\ninit_script=\"/etc/init.d/backend\"\nauthorized_keys=\"/root/.ssh/authorized_keys\"\ntar_file=\"/tmp/backup_backend_$timestamp.tar.gz\"\n\nremote_user=\"backup_sys\"\nremote_host=\"frontend.llw\"\nremote_path=\"/opt/backup/backend\"\n\necho \"Criando diret\u00f3rios tempor\u00e1rios, Data: $timestamp\"\nmkdir -p \"$temp_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Copiando script de inicializa\u00e7\u00e3o, Data: $timestamp\"\ncp \"$init_script\" \"$temp_dir/\" || { echo \"Erro ao copiar o script backend, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Copiando authorized_keys, Data: $timestamp\"\ncp \"$authorized_keys\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Compactando arquivos, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Enviando backup para $remote_host:$remote_path, Data: $timestamp\"\nscp \"$tar_file\" \"$remote_user@$remote_host:$remote_path/\" || { echo \"Erro ao enviar o backup via SCP, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$tar_file\"; exit 1; }\n\necho \"-&gt; Backup enviado com sucesso, Data: $timestamp\"\n\nrm -rf \"$temp_dir\" \"$tar_file\"\nexit 0\n</code></pre>"},{"location":"mensal2/#371-resolvendo-o-nome-do-ip-de-backup","title":"3.7.1 Resolvendo o nome do IP de backup","text":"<p>Escolhemos o nome <code>frontend.llw</code>para a VM Frontend e para o script funcionar corretamente foi necess\u00e1rio resolver o nome do IP de destino editamos o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do frontend com seu respectivo nome:</p> <pre><code>\"192.168.0.3\" frontend.llw\n</code></pre>"},{"location":"mensal2/#38-agendamento-de-script-backup-com-crontab","title":"3.8 Agendamento de Script Backup com Crontab","text":"<p>Editamos o arquivo de agendamento padr\u00e3o do Linux Alpine:</p> <pre><code>vim /etc/crontabs/root\n</code></pre> <p>Adicionamos essa linha ao final do arquivo para rodar o script de backup automaticamente a cada 3 horas:</p> <pre><code>0 */3 * * * /root/backup_backend 1&gt;&gt; /var/log/backup_backend.log 2&gt;&gt; /var/log/backup_backend_error.log\n</code></pre> <p>Utilizamos o comando <code>cat</code> em <code>messages</code> depois do tempo proposto: </p> <pre><code>cat /var/log/messages | grep backup \n</code></pre> <p></p> <p>Resultado do log do Cron</p>"},{"location":"mensal2/#4-configuracao-da-vm-database","title":"4. Configura\u00e7\u00e3o da VM Database","text":"<p>A  VM Database \u00e9 respons\u00e1vel por armazenar o banco de dados que ser\u00e1 utilizado pela API e o SGBD escolhido para o projeto \u00e9 o MariaDB em conjunto com o mysql-client.</p>"},{"location":"mensal2/#41-clonando-a-vm-base","title":"4.1 Clonando a VM Base","text":"<p>Come\u00e7amos fazendo o clone do tipo completo da VM base, que foi criada previamente.  </p> <p></p>"},{"location":"mensal2/#411-configuracao-da-interface-em-modo-bridge","title":"4.1.1 Configura\u00e7\u00e3o da Interface em modo bridge","text":"<p>Para cada VM que clonamos foi necess\u00e1rio atribuir um IP pr\u00f3prio editando o arquivo de interfaces:</p> <pre><code>vim /etc/network/interfaces\n</code></pre> <p>Como a nossa interface em modo bridge \u00e9 o adaptador 2, ela fica identificada como eth1:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 192.168.0.2\n    netmask 255.255.255.0\n</code></pre> <p>Ap\u00f3s salvar o arquivo reiniciamos o servi\u00e7o:</p> <pre><code>rc-service networking restart\n</code></pre>"},{"location":"mensal2/#42-alterando-o-hostname","title":"4.2 Alterando o Hostname","text":"<p>Para diferenciar a VM Database das demais, alteramos seu hostname para database, editando o arquivo de hostname:</p> <pre><code>vim /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"mensal2/#43-configurando-resolucao-de-nome-para-os-ips","title":"4.3 Configurando resolu\u00e7\u00e3o de nome para  os IPs","text":"<p>Para nosso projeto utilizamos o nome <code>backend.llw</code> para o backend e \u00e9 atrav\u00e9s dele que a VM Database vai saber quem est\u00e1 conectado a ela, por isso editamos o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do backend com seu respectivo nome:</p> <pre><code>192.168.0.1 backend.llw\n</code></pre>"},{"location":"mensal2/#44-instalando-mariadb","title":"4.4 Instalando MariaDB","text":"<p>Instalamos o MariaDB em conjunto com o mysql-client:</p> <pre><code>apk add mariadb mysql-client\n</code></pre> <p>MariaDB \u00e9 nosso SGBD, mas utilizamos o mysql-client para acessar a base de dados para manuten\u00e7\u00e3o e configura\u00e7\u00e3o de usu\u00e1rios e permiss\u00f5es.</p> <p>Rodamos o script de setup do MariaDB:</p> <pre><code>/etc/init.d/mariadb setup\n</code></pre> <p>E editamos o arquivo de configura\u00e7\u00e3o:</p> <pre><code>vim /etc/my.cnf.d/mariadb-server.cnf\n</code></pre> <p>Modificamos o arquivo de configura\u00e7\u00f5es do mysql:</p> <pre><code>[mysqld]\n#skip-networking\n\nbind-address=database.llw\nport=3306\n</code></pre> <p>Iniciamos o servi\u00e7o e configuramos para que inicie automaticamente:</p> <pre><code>rc-service mariadb start\nrc-update add mariadb\n</code></pre> <p>Com esse passo o MariaDB vai rodar sempre que ligarmos VM, e vai receber conex\u00f5es de todas as interfaces de rede pela porta 3306 que tiverem permiss\u00e3o.</p>"},{"location":"mensal2/#44-configurando-o-ambiente-do-banco-de-dados","title":"4.4 Configurando o ambiente do Banco de Dados","text":"<p>Entramos no mysql-client utilizando o usu\u00e1rio root, sem senha no primeiro acesso:</p> <pre><code>mysql -u root\n</code></pre> <p>Escolhemos uma senha forte para o root:</p> <pre><code>ALTER USER 'root'@'localhost' IDENTIFIED BY 'SenhaForte';\n</code></pre> <p>Nossa senha do root n\u00e3o ser\u00e1 informada na documenta\u00e7\u00e3o.</p> <p>Criamos a base de dados utilizada por nossa API:</p> <pre><code>create database adv;\n</code></pre> <p>Em seguida criamos o user mysql que ser\u00e1 utilizado pela API para acessar a database:</p> <pre><code>CREATE USER 'llw'@'backend.llw' IDENTIFIED BY 'PePeFaFe!05';\nGRANT SELECT,INSERT,UPDATE,DELETE ON adv.* TO 'llw'@'backend.llw';\n</code></pre> <p>Na primeira execu\u00e7\u00e3o foi dada a permiss\u00e3o de CREATE, por\u00e9m ap\u00f3s a cria\u00e7\u00e3o das tabelas removemos a permiss\u00e3o com REVOKE. </p>"},{"location":"mensal2/#45-configurando-o-script-de-backup","title":"4.5 Configurando o script de backup","text":"<p>Criamos o arquivo em <code>/root/</code>:</p> <pre><code>vim /root/backup_database\n</code></pre> <p>E preenchemos da seguinte forma: </p> <pre><code>#!/bin/ash\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\ntemp_dir=\"/tmp/backup_database_$timestamp\"\ndump_file=\"/tmp/lionlaw_$timestamp.sql\"\nssh_key=\"/root/.ssh/authorized_keys\"\ntar_file=\"/tmp/backup_database_$timestamp.tar.gz\"\nremote_user=\"backup_sys\"\nremote_host=\"frontend.llw\"\nremote_path=\"/opt/backup/database\"\ndb_user=\"USER\"\ndb_pass=\"SENHA\"\ndb_name=\"adv\"\n\necho \"Criando diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"\nmkdir -p \"$temp_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Realizando dump do banco de dados, , Data: $timestamp\"\nmariadb-dump -u\"$db_user\" -p\"$db_pass\" \"$db_name\" &gt; \"$dump_file\" || { echo \"Erro ao gerar o dump, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Copiando dump do banco de dados, Data: $timestamp\"\ncp \"$dump_file\" \"$temp_dir/\" || { echo \"Erro ao dump do banco de dados, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\n\ncp \"$ssh_key\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Compactando tudo, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar arquivos, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Enviando para $remote_user@$remote_host:$remote_path, Data $timestamp\"\nscp \"$tar_file\" \"$remote_user@$remote_host:$remote_path/\" || { echo \"Erro ao enviar o backup via SCP, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\" \"$tar_file\"; exit 1; }\n\necho \"-&gt; Backup enviado com sucesso, Data: $timestamp\"\n\nrm -rf \"$temp_dir\" \"$dump_file\" \"$tar_file\"\nexit 0\n</code></pre> <p>E por fim tornamos o arquivo execut\u00e1vel:</p> <pre><code>chmod +x /root/backup_database\n</code></pre>"},{"location":"mensal2/#46-resolvendo-o-nome-do-ip-de-backup","title":"4.6 Resolvendo o nome do IP de backup","text":"<p>Escolhemos o nome <code>frontend.llw</code>para a VM Frontend e para o script funcionar corretamente foi necess\u00e1rio resolver o nome do IP de destino:</p> <p>editamos o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do frontend com seu respectivo nome:</p> <pre><code>\"192.168.0.3\" frontend.llw\n</code></pre>"},{"location":"mensal2/#47-agendamento-de-script-backup-com-crontab","title":"4.7 Agendamento de Script Backup com Crontab","text":"<p>Editamos o arquivo de agendamento padr\u00e3o do Linux Alpine:</p> <pre><code>vim /etc/crontabs/root\n</code></pre> <p>Adicionamos essa linha ao final do arquivo para rodar o script de backup automaticamente a cada 6 horas:</p> <pre><code>0 */6 * * * /root/backup_database 1&gt;&gt; /var/log/backup_database.log 2&gt;&gt; /var/log/backup_database_error.log\n</code></pre> <p>Utilizamos o comando <code>cat</code> em <code>messages</code> depois do tempo proposto: </p> <pre><code>cat /var/log/messages | grep backup \n</code></pre> <p></p> <p>Resultado do log do Cron</p>"},{"location":"mensal2/#5-seguranca-extra","title":"5. Seguran\u00e7a Extra","text":""},{"location":"mensal2/#51-rede-interna","title":"5.1 Rede Interna","text":""},{"location":"mensal2/#511-configuracao-de-rede-nas-vms","title":"5.1.1 Configura\u00e7\u00e3o de Rede nas VMs","text":"<p>Alteramos o Adaptador 2 das VMs Backend e Database para <code>Rede Interna</code> e nomeamos a rede como llw</p> <p></p> <p>Para a VM Frontend inclu\u00edmos um terceiro adaptador como <code>rede interna</code> e tamb\u00e9m nomeamos como llw</p> <p></p>"},{"location":"mensal2/#512-configuracao-dos-ips","title":"5.1.2 Configura\u00e7\u00e3o dos IPs","text":"<p>O IP escolhido para a rede interna foi 10.10.10.0/29, ent\u00e3o foi necess\u00e1rio configurar o arquivo <code>interfaces</code> e o arquivo de <code>hosts</code> das VMs. </p> <p>Em cada uma delas usamos o comando de editar o arquivo </p> <pre><code>vim /etc/network/interfaces \n</code></pre> <p>VM Frontend </p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 192.168.0.3\n    netmask 255.255.255.0\n\nauto eth2\niface eth2 inet static\n    address 10.10.10.3\n    netmask 255.255.255.248\n    network 10.10.10.0 \n</code></pre> <p>VM Backend </p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 10.10.10.1\n    netmask 255.255.255.248\n    network 10.10.10.0\n</code></pre> <p>VM Database </p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 10.10.10.2\n    netmask 255.255.255.248\n    network 10.10.10.0\n</code></pre> <p>E para os hosts usamos o comando de edi\u00e7\u00e3o do arquivo:</p> <pre><code>vim /etc/hosts \n</code></pre> <p>Resolvemos os nomes para os IPs da rede interna:</p> <pre><code>10.10.10.1 backend.llw\n10.10.10.2 database.llw\n10.10.10.3 frontend.llw\n</code></pre>"},{"location":"mensal2/#523-configuracao-do-nginx","title":"5.2.3 Configura\u00e7\u00e3o do nginx","text":"<p>Editamos o arquivo de configura\u00e7\u00e3o do nginx para configurar o proxy reverso:</p> <pre><code>vim /etc/nginx/http.d/default.conf\n</code></pre> <p>O arquivo foi editado com essas informa\u00e7\u00f5es:</p> <pre><code>server {\n    listen 80;\n    listen 8080;\n    listen [::]:80;\n\n    server_name backend.llw;\n\n    access_log /var/log/nginx/frontend_access.log;\n    error_log /var/log/nginx/frontend_error.log;\n\n    location / {\n        root /opt/frontend;\n        index index.html;\n        try_files $uri $uri/ /index.html;\n    }\n\n    location /api/ {\n        proxy_pass http://backend.llw:8080;\n        proxy_http_version 1.1;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        proxy_pass_request_headers on;\n        proxy_pass_request_body on;\n    }\n\n    location = /404.html {\n        internal;\n    }\n}\n</code></pre>"},{"location":"mensal2/#52-firewall","title":"5.2 Firewall","text":"<p>Utilizamos iptables para bloquear todos o acesso \u00e0s portas inutilizadas.</p> <p>Instalamos iptables em todas as VMs: </p> <pre><code>apk add iptables\n</code></pre> <p>Adicionamos as seguintes regras de tr\u00e1fego:</p> <pre><code>iptables -P INPUT DROP\n</code></pre> <pre><code>iptables -P OUTPUT ACCEPT\n</code></pre> <pre><code>iptables -P FORWARD DROP\n</code></pre> <p>Colocamos o iptables para iniciar no boot:</p> <pre><code>rc-service add iptables boot\n</code></pre> <p>Salvamos as regras do iptables no <code>init.d</code>:</p> <pre><code>/etc/init.d/iptables save\n</code></pre>"},{"location":"mensal2/#521-excessoes-vm-database","title":"5.2.1 Excess\u00f5es VM Database","text":"<pre><code>iptables -A INPUT -p tcp -s backend.llw -d database.llw --dport 3306 -j ACCEPT\n</code></pre> <pre><code>iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n</code></pre>"},{"location":"mensal2/#522-excessoes-vm-backend","title":"5.2.2 Excess\u00f5es VM Backend","text":"<pre><code>iptables -A INPUT -p tcp -s frontend.llw -d backend.llw --dport 8080 -j ACCEPT\n</code></pre> <pre><code>iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n</code></pre>"},{"location":"mensal2/#523-excessoes-vm-frontend","title":"5.2.3 Excess\u00f5es VM Frontend","text":"<pre><code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT\n</code></pre> <pre><code>iptables -A INPUT -p tcp --dport 8080 -j ACCEPT\n</code></pre> <pre><code>iptables -A INPUT -p tcp -s backend.llw -d frontend.llw --dport 22 -j ACCEPT\n</code></pre> <pre><code>iptables -A INPUT -p tcp -s database.llw -d frontend.llw --dport 22 -j ACCEPT\n</code></pre> <pre><code>iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT\n</code></pre>"},{"location":"mensal2/#53-permissoes-do-mariadb","title":"5.3 Permiss\u00f5es do MariaDB","text":"<p>Essa configura\u00e7\u00e3o foi mostrada anteriormente no cap\u00edtulo de Database, mas adicionada a essa sess\u00e3o por tamb\u00e9m fazer parte de um t\u00f3pico extra.</p> <p>Passamos apenas permiss\u00f5es necess\u00e1rias para o usu\u00e1rio mysql do backend, impedindo que ele realize o DROP de tabelas por exemplo:</p> <pre><code>GRANT SELECT,INSERT,UPDATE,DELETE ON adv.* TO 'llw'@'backend.llw';\n</code></pre>"},{"location":"zap/","title":"Relat\u00f3rio OWASP ZAP","text":""},{"location":"zap/#1-csp-failure-to-define-directive-with-no-fallback","title":"1. CSP: Failure to Define Directive with No Fallback","text":"<p>Descri\u00e7\u00e3o:</p> <p>A pol\u00edtica de seguran\u00e7a de conte\u00fado (CSP) falha ao definir diretivas como <code>frame-ancestors</code> e <code>form-action</code>.</p> <p>Recomenda\u00e7\u00e3o:</p> <p>Precisamos configurar o cabe\u00e7alho HTTP <code>Content-Security-Policy</code> incluindo todas as diretivas necess\u00e1rias com valores apropriados.</p> <p>Exemplo:</p> <pre><code>Content-Security-Policy: default-src 'self'; frame-ancestors 'none'; form-action 'self';\n</code></pre>"},{"location":"zap/#2-configuracao-incorreta-entre-dominios-cors","title":"2. Configura\u00e7\u00e3o Incorreta Entre Dom\u00ednios (CORS)","text":"<p>Descri\u00e7\u00e3o:</p> <p>O servidor est\u00e1 permitindo acessos entre dom\u00ednios de qualquer origem <code>(Access-Control-Allow-Origin: \\*)</code>.</p> <p>Recomenda\u00e7\u00e3o:</p> <p>Precisamos configurar o cabe\u00e7alho CORS com um dom\u00ednio confi\u00e1vel ou remova completamente o cabe\u00e7alho se n\u00e3o for necess\u00e1rio.</p> <p>Exemplo:</p> <pre><code>Access-Control-Allow-Origin: https://lionlaw.com\n</code></pre>"},{"location":"zap/#3-content-security-policy-csp-header-not-set","title":"3. Content Security Policy (CSP) Header Not Set","text":"<p>Descri\u00e7\u00e3o:</p> <p>O cabe\u00e7alho de pol\u00edtica de seguran\u00e7a de conte\u00fado n\u00e3o est\u00e1 definido.</p> <p>Recomenda\u00e7\u00e3o:</p> <p>Precisamos adicionar o cabe\u00e7alho <code>Content-Security-Policy</code> com regras para scripts, estilos, imagens, etc.</p> <p>Exemplo:</p> <pre><code>Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.exemplo.com;\n</code></pre>"},{"location":"zap/#4-missing-anti-clickjacking-header","title":"4. Missing Anti-clickjacking Header","text":"<p>Descri\u00e7\u00e3o:</p> <p>Falta prote\u00e7\u00e3o contra clickjacking.</p> <p>Recomenda\u00e7\u00e3o:</p> <p>Uma alternativa \u00e9 utilizar X-Frame-Options ou CSP com frame-ancestors.</p> <p>Exemplos:</p> <pre><code>X-Frame-Options: DENY\n\nContent-Security-Policy: frame-ancestors 'none';\n</code></pre>"},{"location":"zap/#5-x-content-type-options-header-missing","title":"5. X-Content-Type-Options Header Missing","text":"<p>Descri\u00e7\u00e3o:</p> <p>Falta o cabe\u00e7alho que impede o navegador de interpretar tipos MIME incorretamente.</p> <p>Recomenda\u00e7\u00e3o:</p> <p>Ainda precisamos adicionar o cabe\u00e7alho HTTP:</p> <pre><code>X-Content-Type-Options: nosniff\n</code></pre>"},{"location":"zap/#6-divulgacao-de-comentarios","title":"6. Divulga\u00e7\u00e3o de Coment\u00e1rios","text":"<p>Descri\u00e7\u00e3o:</p> <p>Coment\u00e1rios no c\u00f3digo JavaScript podem revelar informa\u00e7\u00f5es sens\u00edveis.</p> <p>Recomenda\u00e7\u00e3o:</p> <p>Removeremos os coment\u00e1rios.</p> <p>Podemos automatizar esse processo com ferramentas de build (Webpack, esbuild, etc).</p>"}]}