{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Instala\u00e7\u00e3o e Configura\u00e7\u00e3o do Alpine Linux no VirtualBox (VM Base)","text":"<p>Este documento explica passo a passo a configura\u00e7\u00e3o realizada na VM Base, e serve como template para as m\u00e1quinas virtuais criadas posteriormente, com a possibilidade de clonar essa base, evitamos a necessidade de refazer configura\u00e7\u00f5es que s\u00e3o comuns a todas elas. Permitindo que o foco fique em configurar apenas o necess\u00e1rio para que determinada m\u00e1quina virtual cumpra o objetivo para o qual foi criada, seja Frontend, Backend, Database ou qualquer possibilidade que possa surgir futuramente. </p>"},{"location":"#1-download-dos-recursos-necessarios","title":"1. Download dos Recursos Necess\u00e1rios","text":"<p>Come\u00e7amos com o download e instala\u00e7\u00e3o de um hypervisor, um software que permite executar v\u00e1rias m\u00e1quinas virtuais em uma \u00fanica m\u00e1quina f\u00edsica. A escolha para esse projeto foi o Oracle VirtualBox.</p> <p>Em seguida  fizemos o download da  ISO do Alpine Linux, em sua vers\u00e3o virtual, que dispensa interface gr\u00e1fica, contando apenas com o Bash, uma interface de linha de comando (CLI) usada para interpretar comandos.</p>"},{"location":"#2-criacao-da-maquina-virtual","title":"2. Cria\u00e7\u00e3o da M\u00e1quina Virtual","text":"<p>Ap\u00f3s instalar o VirtualBox e baixar a ISO do Alpine, criamos a m\u00e1quina m\u00e1quina virtual (VM) com as seguintes especifica\u00e7\u00f5es:</p> <ul> <li>CPU: 1 core  </li> <li>RAM: 512 MB  </li> <li>Disco: 20 GB  </li> <li>ISO de Boot: Alpine Linux (modo virtual)</li> </ul> <p></p>"},{"location":"#3-ajustes-iniciais-da-vm","title":"3. Ajustes Iniciais da VM","text":""},{"location":"#configuracao-de-rede","title":"Configura\u00e7\u00e3o de Rede","text":"<p>Adicionamos uma nova interface de rede em modo Bridge, para permitir que a VM se conecte a outros dispositivos na mesma rede, como se fosse um dispositivo f\u00edsico separado.</p> <p></p>"},{"location":"#4-boot-e-setup-do-alpine-linux","title":"4. Boot e Setup do Alpine Linux","text":"<p>Ao iniciar pela primeira vez, utilizamos o login com root sem informar senha:</p> <ul> <li>Login: <code>root</code> </li> <li>Senha: (vazio)</li> </ul> <p>E o seguinte comando para iniciar a instala\u00e7\u00e3o do Alpine Linux:</p> <pre><code>setup-alpine\n</code></pre>"},{"location":"#5-configuracoes-do-setup-do-alpine-linux","title":"5. Configura\u00e7\u00f5es do Setup do Alpine Linux","text":"<p>Essas foram nossas escolhas para configurar a VM base, mas elas podem ser alteradas mais tarde dependendo da necessidade de cada tipo de VM.</p> <ul> <li>Layout de Teclado: <code>br-br</code> </li> <li>Hostname: <code>localhost</code> </li> <li>Interfaces de Rede: <code>eth0 (NAT)</code>, <code>eth1 (Bridge)</code> </li> <li>Endere\u00e7o IP: <code>DHCP</code> </li> <li>Configura\u00e7\u00e3o Manual da Interface: <code>n</code> </li> <li>Senha do usu\u00e1rio root: <code>root</code> </li> <li>Fuso Hor\u00e1rio: <code>America/Sao_Paulo</code> </li> <li>Proxy: <code>none</code> </li> <li>NTP: <code>chrony</code> </li> <li>Reposit\u00f3rio (Mirror): <code>1</code> </li> <li>Criar um usu\u00e1rio comum: <code>n</code> </li> <li>Servidor SSH: <code>openssh</code> </li> <li>Permitir login root via SSH: <code>prohibit-password</code> </li> <li>Chave SSH para root: <code>none</code> </li> <li>Disco selecionado: <code>sda</code> </li> <li>Modo de uso do disco: <code>sys</code> </li> <li>Apagar dados do disco: <code>y</code></li> </ul>"},{"location":"#6-finalizando-a-instalacao","title":"6. Finalizando a Instala\u00e7\u00e3o","text":"<p>Ap\u00f3s concluir o processo de instala\u00e7\u00e3o, desligamos a m\u00e1quina virtual:</p> <pre><code>poweroff\n</code></pre> <p>Removemos o dispositivo que cont\u00e9m ISO do Alpine, pois o sistema j\u00e1 foi instalado no disco r\u00edgido.</p>"},{"location":"#7-gerenciamento-de-pacotes","title":"7. Gerenciamento de Pacotes","text":""},{"location":"#71-habilitando-repositorios-da-comunidade","title":"7.1 Habilitando Reposit\u00f3rios da Comunidade","text":"<p>Abrimos o arquivo repositories em modo de edi\u00e7\u00e3o:</p> <pre><code>vi /etc/apk/repositories\n</code></pre> <p>Removemos o <code>#</code> na frente do link para habilitar o reposit\u00f3rio <code>community</code>, que possui pacotes utilizados em nosso projeto.</p> <pre><code>http://dl-cdn.alpinelinux.org/alpine/v3.19/community\n</code></pre>"},{"location":"#72-atualizando-o-sistema","title":"7.2 Atualizando o Sistema","text":"<p>Executamos os comandos para atualiza\u00e7\u00e3o dos pacotes: </p> <p>O primeiro lista os pacotes dispon\u00edveis nos reposit\u00f3rios:</p> <pre><code>apk update\n</code></pre> <p>O segundo atualiza os pacotes instalados em caso de existirem atualiza\u00e7\u00f5es:</p> <pre><code>apk upgrade\n</code></pre>"},{"location":"#73-instalando-um-editor-de-texto-alternativo","title":"7.3 Instalando um Editor de Texto Alternativo","text":"<p>Parte do nosso grupo utilizou o editor de texto nano e parte utilizou o vim, para essa documenta\u00e7\u00e3o os exemplos ser\u00e3o com vim: </p> <pre><code>apk add vim\n</code></pre>"},{"location":"#8-melhorando-a-integracao-com-o-host","title":"8. Melhorando a integra\u00e7\u00e3o com o host","text":"<p>Instalamos o  VirtualBox Guest Additions para melhorar a integra\u00e7\u00e3o com o host:</p> <pre><code>apk add virtualbox-guest-additions\n</code></pre> <p>Em seguida iniciamos o servi\u00e7o e configuramos para que inicie automaticamente:</p> <pre><code>rc-service virtualbox-guest-additions start\nrc-update add virtualbox-guest-additions\n</code></pre>"},{"location":"#9-configurando-acesso-ssh","title":"9. Configurando Acesso SSH","text":"<p>Editamos o arquivo de configura\u00e7\u00e3o do SSH para permitir o acesso por senha temporariamente:</p> <pre><code>vim /etc/ssh/sshd_config\n</code></pre> <p>Alteramos duas linhas para permitir conex\u00e3o ssh com root e para permitir login com senha:</p> <pre><code>PermitRootLogin yes\nPasswordAuthentication yes\n</code></pre> <p>E reiniciamos o servi\u00e7o para confirmar as altera\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre>"},{"location":"#10-acesso-via-chave-ssh","title":"10. Acesso via Chave SSH","text":""},{"location":"#101-gerando-chave-no-host","title":"10.1 Gerando Chave no Host","text":"<p>No powershell do Windows geramos um par de chaves:</p> <pre><code>ssh-keygen -t rsa -b 4096 -f id_rsa\n</code></pre> <p>No momento de gerar as chaves deixamos o campo de senha vazio.</p>"},{"location":"#102-preparando-a-vm-para-receber-a-chave","title":"10.2 Preparando a VM para Receber a Chave","text":"<p>Na VM criamos o diret\u00f3rio .ssh:</p> <pre><code>mkdir /root/.ssh\n</code></pre> <p>E no Windows enviamos a chave p\u00fablica para a pasta .ssh da VM via scp:</p> <pre><code>scp .ssh/id_rsa.pub root@192.168.1.108:/root/.ssh/authorized_keys\n</code></pre> <p>Ajustamos as permiss\u00f5es do arquivo enviado:</p> <pre><code>chmod 600 /root/.ssh/authorized_keys\n</code></pre> <p>e em seguida testamos a conex\u00e3o:</p> <pre><code>ssh root@192.168.1.108\n</code></pre>"},{"location":"#103-desabilitando-acesso-por-senha","title":"10.3 Desabilitando Acesso por Senha","text":"<p>Editamos novamente o <code>sshd_config</code>, dessa vez para impedir o acesso por senha:</p> <pre><code>PasswordAuthentication no\n</code></pre> <p>E reiniciamos o servi\u00e7o para aplicar as configura\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre> <p>A partir deste ponto, o acesso \u00e0 VM ser\u00e1 feito exclusivamente via chave SSH e sem utiliza\u00e7\u00e3o de senha.</p>"},{"location":"backend/","title":"Configura\u00e7\u00e3o da VM Backend","text":"<p>A VM Backend \u00e9 respons\u00e1vel por executar a nossa API utilizando o Java 17, ela possui um usu\u00e1rio dedicado backend que executar\u00e1 o processo, e tamb\u00e9m um script de inicializa\u00e7\u00e3o que executar\u00e1 automaticamente ao ligar a m\u00e1quina virtual.</p>"},{"location":"backend/#1-clonando-a-vm-base","title":"1. Clonando a VM Base","text":"<p>Come\u00e7amos fazendo o clone do tipo completo da VM base, que foi criada previamente.  </p> <p></p>"},{"location":"backend/#11-configuracao-da-interface-em-modo-bridge","title":"1.1 Configura\u00e7\u00e3o da Interface em modo bridge","text":"<p>Para cada VM que clonamos foi necess\u00e1rio atribuir um IP pr\u00f3prio editando o arquivo de interfaces:</p> <pre><code>vim /etc/network/interfaces\n</code></pre> <p>Como a nossa interface em modo bridge \u00e9 o adaptador 2, ela fica identificada como eth1:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 192.168.0.1\n    netmask 255.255.255.0\n</code></pre> <p>Ap\u00f3s salvar o arquivo reiniciamos o servi\u00e7o:</p> <pre><code>rc-service networking restart\n</code></pre>"},{"location":"backend/#2-alterando-o-hostname","title":"2. Alterando o Hostname","text":"<p>Para diferenciar a VM Frontend das demais, alteramos seu hostname para frontend, editando o arquivo de hostname:</p> <pre><code>vim /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"backend/#3-configurando-resolucao-de-nome-para-os-ips","title":"3. Configurando resolu\u00e7\u00e3o de nome para  os IPs","text":"<p>Para nosso projeto utilizamos o nome <code>database.llw</code> para o banco de dados e \u00e9 atrav\u00e9s dele que o backend se comunica com a VM de database, ent\u00e3o foi necess\u00e1rio alterar o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP da database com seu respectivo nome:</p> <pre><code>\"192.168.0.2\" database.llw\n</code></pre>"},{"location":"backend/#3-instalando-o-java-17","title":"3. Instalando o Java 17","text":"<p>Instalamos o Java 17 com o comando :</p> <pre><code>apk add openjdk17\n</code></pre>"},{"location":"backend/#4-buildando-o-projeto","title":"4. Buildando o Projeto","text":"<p>No Windows antes de fazer a build do backend, foi necess\u00e1rio configurar corretamente o endere\u00e7o IP da VM Database junto com o usu\u00e1rio e senha do banco de dados.</p> <p>Editamos o arquivo application.properties:</p> <pre><code>spring.datasource.url=jdbc:mysql://database.llw:3306/adv\nspring.datasource.username=advocacia\nspring.datasource.password=PePeFaFe!05\n</code></pre> <p>Depois enviamos o arquivo jar por scp para o diret\u00f3rio <code>/opt/backend</code> que criamos na VM:</p> <pre><code>scp backend.jar root@192.168.105:/opt/backend/\n</code></pre> <p>Ap\u00f3s esse passo executamos o comando:</p> <pre><code>java -jar backend.jar\n</code></pre> <p></p> <p>Como tudo foi configurado corretamente, a aplica\u00e7\u00e3o iniciou.</p> <p></p>"},{"location":"backend/#5-criando-o-script-para-rodar-a-api-automaticamente","title":"5. Criando o script para rodar a API automaticamente","text":"<p>Adicionamos um novo usu\u00e1rio chamado <code>backend</code> que \u00e9 o respons\u00e1vel por rodar a aplica\u00e7\u00e3o e definimos a home dele em <code>/opt/backend</code>:</p> <pre><code>adduser -h /opt/backend backend\n</code></pre> <p>Em seguida dentro do diret\u00f3rio <code>/etc/init.d /</code> abrimos um novo arquivo em branco chamado backend:</p> <pre><code>vim  /etc/init.d/backend\n</code></pre> <p>Preenchemos ele com o seguinte script:</p> <pre><code>#!/sbin/openrc-run\n\ndescription=\"Lionlaw\"\njava=\"/usr/bin/java\"\narquivo=\"/opt/backend/backend.jar\"\npidfile=\"/opt/backend/lionlaw.pid\"\noutput_log=\"/opt/backend/backend.out\"\nusuario=\"backend\"\n\ndepend() {\n    need net\n    after local\n}\n\nstart_pre() {\n    echo \"Iniciando Spring...\"\n}\n\nstart() {\n    cd /opt/backend || exit 1\n    su -s /bin/sh -c \"nohup $java -jar $arquivo &gt; $output_log 2&gt;&amp;1 &amp; echo \\$! &gt; $pidfile\" $usuario\n    echo \"Aguardando LionLaw Iniciar...\"\n    for i in $(seq 1 60); do\n        if netstat -tlnp 2&gt;/dev/null | grep -q \":8080 \"; then\n            echo \"Backend LionLaw iniciado!\"\n            return 0\n        fi\n        sleep 1\n    done\n    echo \"Falha ao iniciar LionLaw.\"\n    return 1\n}\n\nstop() {\n    echo \"Parando servi\u00e7o...\"\n    if [ -f \"$pidfile\" ]; then\n        kill -9 \"$(cat $pidfile)\" &amp;&amp; rm -f \"$pidfile\"\n        echo \"LionLaw parado.\"\n    else\n        echo \"Nenhum servi\u00e7o rodando na porta 8080.\"\n    fi\n}\n</code></pre> <p>Tornamos o arquivo execut\u00e1vel:</p> <pre><code>chmod +x /etc/init.d/backend\n</code></pre> <p>Iniciamos a aplica\u00e7\u00e3o e configuramos para que inicie automaticamente :</p> <pre><code>service backend start\nrc-update add backend \n</code></pre> <p>Com essa configura\u00e7\u00e3o a aplica\u00e7\u00e3o executa automaticamente ao ligar a m\u00e1quina virtual</p> <p></p>"},{"location":"backend/#6-configurando-o-script-de-backup","title":"6. Configurando o script de backup","text":"<p>Criamos o arquivo em <code>/root/</code>:</p> <pre><code>vi /root/backup_backend\n</code></pre> <p>E preenchemos da seguinte forma: </p> <pre><code>#!/bin/ash\n\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\ntemp_dir=\"/tmp/backup_backend_$timestamp\"\ninit_script=\"/etc/init.d/backend\"\nauthorized_keys=\"/root/.ssh/authorized_keys\"\ntar_file=\"/tmp/backup_backend_$timestamp.tar.gz\"\n\nremote_user=\"backup_sys\"\nremote_host=\"frontend.llw\"\nremote_path=\"/opt/backup/backend\"\n\necho \"Criando diret\u00f3rios tempor\u00e1rios, Data: $timestamp\"\nmkdir -p \"$temp_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Copiando script de inicializa\u00e7\u00e3o, Data: $timestamp\"\ncp \"$init_script\" \"$temp_dir/\" || { echo \"Erro ao copiar o script backend, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Copiando authorized_keys, Data: $timestamp\"\ncp \"$authorized_keys\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Compactando arquivos, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Enviando backup para $remote_host:$remote_path, Data: $timestamp\"\nscp \"$tar_file\" \"$remote_user@$remote_host:$remote_path/\" || { echo \"Erro ao enviar o backup via SCP, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$tar_file\"; exit 1; }\n\necho \"-&gt; Backup enviado com sucesso, Data: $timestamp\"\n\nrm -rf \"$temp_dir\" \"$tar_file\"\nexit 0\n</code></pre>"},{"location":"backend/#61-resolvendo-o-nome-do-ip-de-backup","title":"6.1 Resolvendo o nome do IP de backup","text":"<p>Escolhemos o nome <code>frontend.llw</code>para a VM Frontend e para o script funcionar corretamente foi necess\u00e1rio resolver o nome do IP de destino:</p> <p>editamos o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do frontend com seu respectivo nome:</p> <pre><code>\"192.168.0.3\" frontend.llw\n</code></pre>"},{"location":"backend/#7-agendamento-de-script-backup-com-crontab","title":"7. Agendamento de Script Backup com Crontab","text":"<p>Editamos o arquivo de agendamento padr\u00e3o do Linux Alpine:</p> <pre><code>vim /etc/crontabs/root\n</code></pre> <p>Adicionamos essa linha ao final do arquivo para rodar o script de backup automaticamente a cada 3 horas:</p> <pre><code>0 */3 * * * /root/backup_backend 1&gt;&gt; /var/log/backup_backend.log 2&gt;&gt; /var/log/backup_backend_error.log\n</code></pre> <p>Resultado do log do Cron: </p> <p></p>"},{"location":"database/","title":"Configura\u00e7\u00e3o da VM Database","text":"<p>A  VM Database \u00e9 respons\u00e1vel por armazenar o banco de dados que ser\u00e1 utilizado pela API e o SGBD escolhido para o projeto \u00e9 o MariaDB em conjunto com o mysql-client.</p>"},{"location":"database/#1-clonando-a-vm-base","title":"1. Clonando a VM Base","text":"<p>Come\u00e7amos fazendo o clone do tipo completo da VM base, que foi criada previamente.  </p> <p></p>"},{"location":"database/#11-configuracao-da-interface-em-modo-bridge","title":"1.1 Configura\u00e7\u00e3o da Interface em modo bridge","text":"<p>Para cada VM que clonamos foi necess\u00e1rio atribuir um IP pr\u00f3prio editando o arquivo de interfaces:</p> <pre><code>vim /etc/network/interfaces\n</code></pre> <p>Como a nossa interface em modo bridge \u00e9 o adaptador 2, ela fica identificada como eth1:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 192.168.0.2\n    netmask 255.255.255.0\n</code></pre> <p>Ap\u00f3s salvar o arquivo reiniciamos o servi\u00e7o:</p> <pre><code>rc-service networking restart\n</code></pre>"},{"location":"database/#2-alterando-o-hostname","title":"2. Alterando o Hostname","text":"<p>Para diferenciar a VM Database das demais, alteramos seu hostname para database, editando o arquivo de hostname:</p> <pre><code>vim /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"database/#3-configurando-resolucao-de-nome-para-os-ips","title":"3. Configurando resolu\u00e7\u00e3o de nome para  os IPs","text":"<p>Para nosso projeto utilizamos o nome <code>backend.llw</code> para o backend e \u00e9 atrav\u00e9s dele que a VM Database vai saber quem est\u00e1 conectado a ela, por isso editamos o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do backend com seu respectivo nome:</p> <pre><code>\"192.168.0.1\" backend.llw\n</code></pre>"},{"location":"database/#4-instalando-mariadb","title":"4. Instalando MariaDB","text":"<p>Instalamos o MariaDB em conjunto com o mysql-client:</p> <pre><code>apk add mariadb mysql-client\n</code></pre> <p>MariaDB \u00e9 nosso SGBD, mas utilizamos o mysql-client para acessar a base de dados para manuten\u00e7\u00e3o e configura\u00e7\u00e3o de usu\u00e1rios e permiss\u00f5es.</p> <p>Rodamos o script de setup do MariaDB:</p> <pre><code>/etc/init.d/mariadb setup\n</code></pre> <p>E editamos o arquivo de configura\u00e7\u00e3o:</p> <pre><code>vim /etc/my.cnf.d/mariadb-server.cnf\n</code></pre> <p>Modificamos o arquivo de configura\u00e7\u00f5es do mysql:</p> <pre><code>[mysqld]\n#skip-networking\n\nbind-address=database.llw\nport=3306\n</code></pre> <p>Iniciamos o servi\u00e7o e configuramos para que inicie automaticamente:</p> <pre><code>rc-service mariadb start\nrc-update add mariadb\n</code></pre> <p>Com esse passo o MariaDB vai rodar sempre que ligarmos VM, e vai receber conex\u00f5es de todas as interfaces de rede pela porta 3306 que tiverem permiss\u00e3o.</p>"},{"location":"database/#4-configurando-o-ambiente-do-banco-de-dados","title":"4. Configurando o ambiente do Banco de Dados","text":"<p>Entramos no mysql-client utilizando o usu\u00e1rio root, sem senha no primeiro acesso:</p> <pre><code>mysql -u root\n</code></pre> <p>Escolhemos uma senha forte para o root:</p> <pre><code>ALTER USER 'root'@'localhost' IDENTIFIED BY 'SenhaForte';\n</code></pre> <p>Nossa senha do root n\u00e3o ser\u00e1 informada na documenta\u00e7\u00e3o.</p> <p>Criamos a base de dados utilizada por nossa API:</p> <pre><code>create database adv;\n</code></pre> <p>Em seguida criamos o user mysql que ser\u00e1 utilizado pela API para acessar a database:</p> <pre><code>CREATE USER 'llw'@'backend.llw' IDENTIFIED BY 'PePeFaFe!05';\nGRANT SELECT,INSERT,UPDATE,DELETE ON adv.* TO 'llw'@'backend.llw';\n</code></pre> <p>Na primeira execu\u00e7\u00e3o foi dada a permiss\u00e3o de CREATE, por\u00e9m ap\u00f3s a cria\u00e7\u00e3o das tabelas removemos a permiss\u00e3o com REVOKE. </p>"},{"location":"database/#6-configurando-o-script-de-backup","title":"6. Configurando o script de backup","text":"<p>Criamos o arquivo em <code>/root/</code>:</p> <pre><code>vi /root/backup_database\n</code></pre> <p>E preenchemos da seguinte forma: </p> <pre><code>#!/bin/ash\n\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\n\ntemp_dir=\"/tmp/backup_database_$timestamp\"\n\ndump_file=\"/tmp/lionlaw_$timestamp.sql\"\nssh_key=\"/root/.ssh/authorized_keys\"\n\ntar_file=\"/tmp/backup_database_$timestamp.tar.gz\"\n\nremote_user=\"backup_sys\"\nremote_host=\"frontend.llw\"\nremote_path=\"/opt/backup/database\"\n\ndb_user=\"USER\"\ndb_pass=\"SENHA\"\ndb_name=\"adv\"\n\necho \"Criando diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"\nmkdir -p \"$temp_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Realizando dump do banco de dados, , Data: $timestamp\"\nmariadb-dump -u\"$db_user\" -p\"$db_pass\" \"$db_name\" &gt; \"$dump_file\" || { echo \"Erro ao gerar o dump, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Copiando dump do banco de dados, Data: $timestamp\"\ncp \"$dump_file\" \"$temp_dir/\" || { echo \"Erro ao dump do banco de dados, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\n\ncp \"$ssh_key\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Compactando tudo, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar arquivos, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Enviando para $remote_user@$remote_host:$remote_path, Data $timestamp\"\nscp \"$tar_file\" \"$remote_user@$remote_host:$remote_path/\" || { echo \"Erro ao enviar o backup via SCP, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\" \"$tar_file\"; exit 1; }\n\necho \"-&gt; Backup enviado com sucesso, Data: $timestamp\"\n\nrm -rf \"$temp_dir\" \"$dump_file\" \"$tar_file\"\nexit 0\n</code></pre> <p>E por fim tornamos o arquivo execut\u00e1vel:</p> <pre><code>chmod +x /root/backup_database\n</code></pre>"},{"location":"database/#61-resolvendo-o-nome-do-ip-de-backup","title":"6.1 Resolvendo o nome do IP de backup","text":"<p>Escolhemos o nome <code>frontend.llw</code>para a VM Frontend e para o script funcionar corretamente foi necess\u00e1rio resolver o nome do IP de destino:</p> <p>editamos o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do frontend com seu respectivo nome:</p> <pre><code>\"192.168.0.3\" frontend.llw\n</code></pre>"},{"location":"database/#7-agendamento-de-script-backup-com-crontab","title":"7. Agendamento de Script Backup com Crontab","text":"<p>Editamos o arquivo de agendamento padr\u00e3o do Linux Alpine:</p> <pre><code>vim /etc/crontabs/root\n</code></pre> <p>Adicionamos essa linha ao final do arquivo para rodar o script de backup automaticamente a cada 6 horas:</p> <pre><code>0 */6 * * * /root/backup_database 1&gt;&gt; /var/log/backup_database.log 2&gt;&gt; /var/log/backup_database_error.log\n</code></pre> <p>Resultado do log do Cron: </p> <p></p>"},{"location":"frontend/","title":"Configura\u00e7\u00e3o da VM Frontend","text":"<p>A VM Frontend \u00e9 respons\u00e1vel por hospedar a interface do sistema utilizando o servidor web nginx, e tamb\u00e9m atua como servidor de backups, armazenando os arquivos de backup de todas as outras VMs, incluindo ela mesma. Por esse motivo, ela possui um arquivo authorized_kyes com a chave p\u00fablica rsa de cada uma das outras m\u00e1quinas virtuais em seu usu\u00e1rio backup_sys, permitindo que os arquivos de backup sejam recebidos via scp.</p>"},{"location":"frontend/#1-clonando-a-vm-base","title":"1. Clonando a VM Base","text":"<p>Come\u00e7amos fazendo o clone do tipo completo da VM base, que foi criada previamente.  </p> <p></p>"},{"location":"frontend/#11-configuracao-da-interface-em-modo-bridge","title":"1.1 Configura\u00e7\u00e3o da Interface em modo bridge","text":"<p>Para cada VM que clonamos foi necess\u00e1rio atribuir um IP pr\u00f3prio editando o arquivo de interfaces:</p> <pre><code>vim /etc/network/interfaces\n</code></pre> <p>Como a nossa interface em modo bridge \u00e9 o adaptador 2, ela fica identificada como eth1:</p> <pre><code>auto lo\niface lo inet loopback\n\nauto eth0\niface eth0 inet dhcp\n\nauto eth1\niface eth1 inet static\n    address 192.168.0.3\n    netmask 255.255.255.0\n</code></pre> <p>Ap\u00f3s salvar o arquivo reiniciamos o servi\u00e7o:</p> <pre><code>rc-service networking restart\n</code></pre>"},{"location":"frontend/#2-alterando-o-hostname","title":"2. Alterando o Hostname","text":"<p>Para diferenciar a VM Frontend das demais, alteramos seu hostname para frontend, editando o arquivo de hostname:</p> <pre><code>vim /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"frontend/#3-configurando-resolucao-de-nome-para-os-ips","title":"3. Configurando resolu\u00e7\u00e3o de nome para  os IPs","text":"<p>Para nosso projeto utilizamos o nome <code>backend.llw</code> para o backend e \u00e9 atrav\u00e9s dele que o frontend realiza requisi\u00e7\u00f5es, ent\u00e3o foi necess\u00e1rio alterar o arquivo <code>hosts</code>:</p> <pre><code>vim /etc/hosts\n</code></pre> <p>E informamos o IP do backend com seu respectivo nome:</p> <pre><code>\"192.168.0.1\" backend.llw\n</code></pre>"},{"location":"frontend/#4-arquivo-hosts-no-windows","title":"4. Arquivo Hosts no Windows","text":"<p>Editamos o arquivo hosts do Windows com permiss\u00f5es de administrador que fica localizado no seguinte diret\u00f3rio:</p> <pre><code>C:\\Windows\\System32\\drivers\\etc\\hosts\n</code></pre> <p>E informamos o IP do backend com seu respectivo nome assim como fizemos na VM:</p> <pre><code>192.168.1.106 backend.llw\n</code></pre>"},{"location":"frontend/#5-instalando-o-nginx","title":"5. Instalando o Nginx","text":"<p>Instalamos o servidor web nginx:</p> <pre><code>apk add nginx\n</code></pre> <p>Iniciamos o servi\u00e7o e configuramos para que inicie automaticamente:</p> <pre><code>rc-service nginx start\nrc-update add nginx\n</code></pre>"},{"location":"frontend/#6-configurando-o-nginx","title":"6. Configurando o Nginx","text":"<p>Editamos o arquivo de configura\u00e7\u00e3o do nginx:</p> <pre><code>vim /etc/nginx/http.d/default.conf\n</code></pre> <p>Adicionamos logs de acesso e de erros no arquivo:</p> <pre><code>access_log /var/log/nginx/frontend_access.log;\nerror_log /var/log/nginx/frontend_error.log;\n</code></pre> <p>Indicamos o caminho onde os nossos arquivos est\u00e1ticos de frontend est\u00e3o localizados:</p> <pre><code>location / {\n    root /opt/frontend;\n    index index.html;\n    try_files $uri $uri/ /index.html;\n}\n</code></pre> <p>E recarregamos o nginx para confirmar as altera\u00e7\u00f5es</p> <pre><code>nginx -s reload\n</code></pre>"},{"location":"frontend/#7-buildando-o-frontend","title":"7. Buildando o Frontend","text":"<p>No Windows antes de fazer o build do frontend, foi necess\u00e1rio configurar corretamente o endere\u00e7o IP da API Backend. </p> <p>Editamos o arquivo <code>environment.server.ts</code> do angular:</p> <pre><code>export const environment = {\n  production: true,\n  apiUrl: 'http://backend.llw:8080'\n};\n</code></pre> <p>Realizamos o build e compactamos os arquivos em um .zip, para s\u00f3 ent\u00e3o realizar o envio via scp para a VM no diret\u00f3rio que criamos em <code>/opt/frontend</code></p> <pre><code>scp site.zip root@192.168.1.105:/opt/frontend/\n</code></pre> <p>J\u00e1 na VM descompactamos o arquivo usando o comando:</p> <pre><code>unzip site.zip\n</code></pre> <p>Com esse passo j\u00e1 foi poss\u00edvel visualizar a tela inicial do projeto utilizando o ip da VM Frontend no navegador.</p> <p></p>"},{"location":"frontend/#8-preparando-o-ambiente-para-o-backup","title":"8. Preparando o ambiente para o backup","text":"<p>Criamos um diret\u00f3rio para armazenar os backups:</p> <pre><code>mkdir /opt/backup/\n</code></pre> <p>Em seguida diret\u00f3rios que separam os backups buscando organizar os arquivos:</p> <pre><code>mkdir /opt/backup/frontend/\nmkdir /opt/backup/backend/\nmkdir /opt/backup/database/\n</code></pre> <p>E por fim adicionamos um novo usu\u00e1rio chamado <code>backup_sys</code> definindo a home dele dentro do diret\u00f3rio de backups:</p> <pre><code>adduser -h /opt/backup backup_sys\n</code></pre>"},{"location":"frontend/#9-recebendo-as-chaves-rsa-das-outras-vms","title":"9. Recebendo as chaves RSA das outras VM's:","text":""},{"location":"frontend/#91-criando-o-par-de-chaves","title":"9.1 Criando o par de chaves","text":"<p>Na VM Backend e Database criamos as chaves RSA:</p> <pre><code>ssh-keygen -t rsa -b 4096 -f id_rsa\n</code></pre> <p>E na VM Frontend editamos o arquivo de configura\u00e7\u00e3o do ssh: </p> <pre><code>vim /etc/ssh/sshd_config\n</code></pre> <p>Permitimos o login com senha provisoriamente, apenas para conseguirmos enviar a chave p\u00fablica:</p> <pre><code>PasswordAuthentication yes\n</code></pre> <p>Reiniciamos o servi\u00e7o para aplicar as configura\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre>"},{"location":"frontend/#92-enviando-a-chave-publica-para-backup_sys","title":"9.2 Enviando a chave p\u00fablica para backup_sys","text":"<p>Enviamos a chave p\u00fablica da VM Backend para o backup_sys modificando o nome para <code>authorized_keys</code>:</p> <pre><code>scp id_rsa.pub backup_sys@frontend.llw:/opt/backup/.ssh/authorized_keys\n</code></pre> <p>Em seguida enviamos a chave p\u00fablica da VM Database para o backup_sys, mas sem dar um nome diferente para a chave:</p> <pre><code>scp id_rsa.pub backup_sys@frontend.llw:/opt/backup/.ssh/\n</code></pre> <p>Na VM Frontend, utilizamos o comando cat para adicionar a segunda chave p\u00fablica no final do arquivo authorized_keys:</p> <pre><code>cat /opt/backup/.ssh/id_rsa.pub &gt;&gt; /opt/backup/.ssh/authorized_keys\n</code></pre> <p>Apagamos o arquivo id_rsa.pub que ficou sobrando:</p> <pre><code>rm /opt/backup/.ssh/id_rsa.pub\n</code></pre> <p>Modificamos as permiss\u00f5es da chave:</p> <pre><code>chmod 600 /opt/backup/.ssh/authorized_keys\n</code></pre> <p>E alteramos o propriet\u00e1rio dessa pasta .ssh localizada em <code>/opt/backup</code>:</p> <pre><code>chown -R backup_sys:backup_sys /opt/backup/.ssh\n</code></pre>"},{"location":"frontend/#93-retirando-a-autenticacao-por-senha","title":"9.3 Retirando a autentica\u00e7\u00e3o por senha","text":"<p>Por fim editamos novamente o <code>sshd_config</code>, dessa vez para impedir o acesso por senha:</p> <pre><code>PasswordAuthentication no\n</code></pre> <p>E reiniciamos o servi\u00e7o para aplicar as configura\u00e7\u00f5es uma \u00faltima vez:</p> <pre><code>rc-service sshd restart\n</code></pre>"},{"location":"frontend/#10-configurando-o-script-de-backup-local","title":"10. Configurando o script de backup local","text":"<p>Criamos o arquivo em <code>/root/</code>:</p> <pre><code>vi /root/backup_front\n</code></pre> <p>E preenchemos da seguinte forma: </p> <pre><code>#!/bin/sh\n\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\ntemp_dir=\"/tmp/backup_front_$timestamp\"\nfront_dir=\"$temp_dir/front\"\nfront_end=\"/opt/frontend\"\nauthorized_keys=\"/root/.ssh/authorized_keys\"\ntar_file=\"/opt/backup/frontend/backup_front_$timestamp.tar.gz\"\n\necho \"Criando diret\u00f3rios tempor\u00e1rios, Data: $timestamp\"\nmkdir -p \"$front_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Copiando arquivos do frontend, Data: $timestamp\"\ncp -r \"$front_end/\"* \"$front_dir/\" || { echo \"Erro ao copiar arquivos do frontend, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Copiando authorized_keys, Data: $timestamp\"\ncp \"$authorized_keys\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Compactando tudo, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"-&gt; Backup criado com sucesso, Data: $timestamp \"\n\nrm -rf \"$temp_dir\"\nexit 0\n</code></pre> <p>E por fim tornamos o arquivo execut\u00e1vel:</p> <pre><code>chmod +x /root/backup_front\n</code></pre>"},{"location":"frontend/#11-agendamento-de-script-backup-com-crontab","title":"11. Agendamento de Script Backup com Crontab","text":"<p>Editamos o arquivo de agendamento padr\u00e3o do Linux Alpine:</p> <pre><code>vim /etc/crontabs/root\n</code></pre> <p>Adicionamos essa linha ao final do arquivo para rodar o script de backup automaticamente a cada 3 horas:</p> <pre><code>0 */3 * * * /root/backup_front 1&gt;&gt; /var/log/backup_front.log 2&gt;&gt; /var/log/backup_front_error.log\n</code></pre> <p>Resultado do log do Cron: </p> <p></p>"}]}