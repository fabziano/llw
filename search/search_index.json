{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Instala\u00e7\u00e3o e Configura\u00e7\u00e3o do Alpine Linux no VirtualBox (VM Base)","text":"<p>Este documento explica passo a passo a configura\u00e7\u00e3o realizada na VM Base, e serve como template para as m\u00e1quinas virtuais criadas posteriormente, com a possibilidade de clonar essa base, evitamos a necessidade de refazer configura\u00e7\u00f5es que s\u00e3o comuns a todas elas. Permitindo que o foco fique em configurar apenas o necess\u00e1rio para que determinada m\u00e1quina virtual cumpra o objetivo para o qual foi criada, seja Frontend, Backend, Database ou qualquer possibilidade que possa surgir futuramente. </p>"},{"location":"#1-download-dos-recursos-necessarios","title":"1. Download dos Recursos Necess\u00e1rios","text":"<p>Come\u00e7amos com o download e instala\u00e7\u00e3o de um hypervisor, um software que permite executar v\u00e1rias m\u00e1quinas virtuais em uma \u00fanica m\u00e1quina f\u00edsica. A escolha para esse projeto foi o Oracle VirtualBox.</p> <p>Em seguida  fizemos o download da  ISO do Alpine Linux, em sua vers\u00e3o virtual, que dispensa interface gr\u00e1fica, contando apenas com o Bash, uma interface de linha de comando (CLI) usada para interpretar comandos.</p>"},{"location":"#2-criacao-da-maquina-virtual","title":"2. Cria\u00e7\u00e3o da M\u00e1quina Virtual","text":"<p>Ap\u00f3s instalar o VirtualBox e baixar a ISO do Alpine, criamos a m\u00e1quina m\u00e1quina virtual (VM) com as seguintes especifica\u00e7\u00f5es:</p> <ul> <li>CPU: 1 core  </li> <li>RAM: 512 MB  </li> <li>Disco: 20 GB  </li> <li>ISO de Boot: Alpine Linux (modo virtual)</li> </ul>"},{"location":"#3-ajustes-iniciais-da-vm","title":"3. Ajustes Iniciais da VM","text":""},{"location":"#configuracao-de-rede","title":"Configura\u00e7\u00e3o de Rede","text":"<p>Adicionamos uma nova interface de rede em modo Bridge, para permitir que a VM se conecte a outros dispositivos na mesma rede, como se fosse um dispositivo f\u00edsico separado.</p>"},{"location":"#4-boot-e-setup-do-alpine-linux","title":"4. Boot e Setup do Alpine Linux","text":"<p>Ao iniciar pela primeira vez, utilizamos o login com root sem informar senha:</p> <ul> <li>Login: <code>root</code> </li> <li>Senha: (vazio)</li> </ul> <p>E o seguinte comando para iniciar a instala\u00e7\u00e3o do Alpine Linux:</p> <pre><code>setup-alpine\n</code></pre>"},{"location":"#5-configuracoes-do-setup-do-alpine-linux","title":"5. Configura\u00e7\u00f5es do Setup do Alpine Linux","text":"<p>Essas foram nossas escolhas para configurar a VM base, mas elas podem ser alteradas mais tarde dependendo da necessidade de cada tipo de VM.</p> <ul> <li>Layout de Teclado: <code>br-br</code> </li> <li>Hostname: <code>localhost</code> </li> <li>Interfaces de Rede: <code>eth0 (NAT)</code>, <code>eth1 (Bridge)</code> </li> <li>Endere\u00e7o IP: <code>DHCP</code> </li> <li>Configura\u00e7\u00e3o Manual da Interface: <code>n</code> </li> <li>Senha do usu\u00e1rio root: <code>root</code> </li> <li>Fuso Hor\u00e1rio: <code>America/Sao_Paulo</code> </li> <li>Proxy: <code>none</code> </li> <li>NTP: <code>chrony</code> </li> <li>Reposit\u00f3rio (Mirror): <code>1</code> </li> <li>Criar um usu\u00e1rio comum: <code>n</code> </li> <li>Servidor SSH: <code>openssh</code> </li> <li>Permitir login root via SSH: <code>prohibit-password</code> </li> <li>Chave SSH para root: <code>none</code> </li> <li>Disco selecionado: <code>sda</code> </li> <li>Modo de uso do disco: <code>sys</code> </li> <li>Apagar dados do disco: <code>y</code></li> </ul>"},{"location":"#6-finalizando-a-instalacao","title":"6. Finalizando a Instala\u00e7\u00e3o","text":"<p>Ap\u00f3s concluir o processo de instala\u00e7\u00e3o, desligamos a m\u00e1quina virtual:</p> <pre><code>poweroff\n</code></pre> <p>Removemos o dispositivo que cont\u00e9m ISO do Alpine, pois o sistema j\u00e1 foi instalado no disco r\u00edgido.</p>"},{"location":"#7-gerenciamento-de-pacotes","title":"7. Gerenciamento de Pacotes","text":""},{"location":"#71-habilitando-repositorios-da-comunidade","title":"7.1 Habilitando Reposit\u00f3rios da Comunidade","text":"<p>Abrimos o arquivo repositories em modo de edi\u00e7\u00e3o:</p> <pre><code>vi /etc/apk/repositories\n</code></pre> <p>Removemos o <code>#</code> na frente do link para habilitar o reposit\u00f3rio <code>community</code>, que possui pacotes utilizados em nosso projeto.</p> <pre><code>http://dl-cdn.alpinelinux.org/alpine/v3.19/community\n</code></pre>"},{"location":"#72-atualizando-o-sistema","title":"7.2 Atualizando o Sistema","text":"<p>Executamos os comandos para atualiza\u00e7\u00e3o dos pacotes: </p> <p>O primeiro lista os pacotes dispon\u00edveis nos reposit\u00f3rios:</p> <pre><code>apk update\n</code></pre> <p>O segundo atualiza os pacotes instalados em caso de existirem atualiza\u00e7\u00f5es:</p> <pre><code>apk upgrade\n</code></pre>"},{"location":"#73-instalando-um-editor-de-texto-alternativo","title":"7.3 Instalando um Editor de Texto Alternativo","text":"<p>Parte do nosso grupo utilizou o editor de texto nano e parte utilizou o vim, para essa documenta\u00e7\u00e3o os exemplos ser\u00e3o com vim: </p> <pre><code>apk add vim\n</code></pre>"},{"location":"#8-melhorando-a-integracao-com-o-host","title":"8. Melhorando a integra\u00e7\u00e3o com o host","text":"<p>Instalamos o  VirtualBox Guest Additions para melhorar a integra\u00e7\u00e3o com o host:</p> <pre><code>apk add virtualbox-guest-additions\n</code></pre> <p>Em seguida iniciamos o servi\u00e7o e configuramos para que inicie automaticamente:</p> <pre><code>rc-service virtualbox-guest-additions start\nrc-update add virtualbox-guest-additions\n</code></pre>"},{"location":"#9-configurando-acesso-ssh","title":"9. Configurando Acesso SSH","text":"<p>Editamos o arquivo de configura\u00e7\u00e3o do SSH para permitir o acesso por senha temporariamente:</p> <pre><code>vim /etc/ssh/sshd_config\n</code></pre> <p>Alteramos duas linhas para permitir conex\u00e3o ssh com root e para permitir login com senha:</p> <pre><code>PermitRootLogin yes\nPasswordAuthentication yes\n</code></pre> <p>E reiniciamos o servi\u00e7o para confirmar as altera\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre>"},{"location":"#10-acesso-via-chave-ssh","title":"10. Acesso via Chave SSH","text":""},{"location":"#101-gerando-chave-no-host","title":"10.1 Gerando Chave no Host","text":"<p>No powershell do Windows geramos um par de chaves:</p> <pre><code>ssh-keygen -t rsa -b 4096 -f id_rsa\n</code></pre> <p>No momento de gerar as chaves deixamos o campo de senha vazio.</p>"},{"location":"#102-preparando-a-vm-para-receber-a-chave","title":"10.2 Preparando a VM para Receber a Chave","text":"<p>Na VM criamos o diret\u00f3rio .ssh:</p> <pre><code>mkdir /root/.ssh\n</code></pre> <p>E no Windows enviamos a chave p\u00fablica para a pasta .ssh da VM via scp:</p> <pre><code>scp .ssh/id_rsa.pub root@192.168.1.108:/root/.ssh/authorized_keys\n</code></pre> <p>Ajustamos as permiss\u00f5es do arquivo enviado:</p> <pre><code>chmod 600 /root/.ssh/authorized_keys\n</code></pre> <p>e em seguida testamos a conex\u00e3o:</p> <pre><code>ssh root@192.168.1.108\n</code></pre>"},{"location":"#103-desabilitando-acesso-por-senha","title":"10.3 Desabilitando Acesso por Senha","text":"<p>Editamos novamente o <code>sshd_config</code>, dessa vez para impedir o acesso por senha:</p> <pre><code>PasswordAuthentication no\n</code></pre> <p>E reiniciamos o servi\u00e7o para aplicar as configura\u00e7\u00f5es:</p> <pre><code>rc-service sshd restart\n</code></pre> <p>A partir deste ponto, o acesso \u00e0 VM ser\u00e1 feito exclusivamente via chave SSH e sem utiliza\u00e7\u00e3o de senha.</p>"},{"location":"backend/","title":"Configura\u00e7\u00e3o da VM Backend","text":"<p>Este arquivo documenta, passo a passo, todo o processo de configura\u00e7\u00e3o da VM Back-End. Ela ser\u00e1 respons\u00e1vel por executar a nossa API utilizando o Java 17, ela ter\u00e1 um usu\u00e1rio dedicado backend que executar\u00e1 o processo, e tambem um script de inicializa\u00e7\u00e3o que executar\u00e1 automaticamente ao ligar a maquina.</p>"},{"location":"backend/#1-clonando-a-vm-base","title":"1. Clonando a VM Base","text":"<p>Come\u00e7aremos clonando a VM base, que j\u00e1 foi criada previamente. A configura\u00e7\u00e3o dessa VM base est\u00e1 documentada no Arquivo de configura\u00e7\u00e3o da VM base.</p>"},{"location":"backend/#2-configuracoes-iniciais-da-vm-back-end","title":"2. Configura\u00e7\u00f5es Iniciais da VM Back-End","text":"<p>Antes de passar para as configura\u00e7\u00f5es dessa VM vamos personalizar a identidade dela e garantir que ela esteja preparada para se comunicar corretamente com as outras.</p>"},{"location":"backend/#alterando-o-hostname","title":"Alterando o Hostname","text":"<p>Para diferenciar a VM Back-End das demais, alteraremos seu hostname para backend, editando o arquivo:</p> <pre><code>vi /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"backend/#definindo-uma-senha-segura-para-o-usuario-root","title":"Definindo uma senha segura para o usu\u00e1rio root","text":"<p>Se ainda n\u00e3o definiu uma senha forte para o root durante o setup da VM, fa\u00e7a-o:</p> <pre><code>passwd\n</code></pre> <p>Crie uma senha segura e guarde-a. Considere uma senha com no m\u00ednimo 12 caracteres, incluindo letras mai\u00fasculas, min\u00fasculas, n\u00fameros e s\u00edmbolos, j\u00e1 que viemos da VM-base, a senha antiga era root (nada seguro).</p>"},{"location":"backend/#configurando-resolucao-de-ips-no-arquivo-etchosts","title":"Configurando resolu\u00e7\u00e3o de IPs no arquivo /etc/hosts","text":"<p>Para que o back-end possa fazer a conex\u00e3o com o endere\u00e7o correto ajuste a resolu\u00e7\u00e3o de ip de hosts, por isso, edite o arquivo:</p> <pre><code>vi /etc/hosts\n</code></pre> <p>E adicione a resolu\u00e7\u00e3o do ip corretamente:</p> <pre><code>\"192.168.0.1\" database.llw\n</code></pre> <p>O ip acima \u00e9 apenas um exemplo, coloque o ip da sua VM Database no lugar daquele, e saiba que sempre que nessa documenta\u00e7\u00e3o for referida um ip com fim .llw significa que ele est\u00e1 resolvendo o ip de uma das VM's, Front, Back ou Database.</p> <p>Priorize um reboot da maquina, ap\u00f3s mudan\u00e7as no arquivo de hosts, porque por mais que \"n\u00e3o precise\", outros servi\u00e7os ler\u00e3o o arquivo de hosts somente na hora do boot, e n\u00e3o vao atualizando sua leitura, por isso nomes podem n\u00e3o ser resolvidos corretamente.</p> <p>Isso permite que a VM Back-End resolva o dom\u00ednio <code>database.llw</code> para o IP especificado, facilitando poss\u00edveis mudan\u00e7as de IP no ambiente sem a necessidade de re-buildar o projeto.</p>"},{"location":"backend/#3-instalando-o-java-17","title":"3. Instalando o Java 17","text":"<p>Adicione o servi\u00e7o openjdk17 e todas suas depedencias:</p> <pre><code>apk add openjdk17\n</code></pre>"},{"location":"backend/#4-buildando-o-projeto","title":"4. Buildando o Projeto","text":"<p>Antes de buildar o projeto, revise as configura\u00e7\u00f5es de conex\u00e3o com o banco no arquivo application.properties:</p> <pre><code>spring.datasource.url=jdbc:mysql://database.llw:3306/adv\nspring.datasource.username=advocacia\nspring.datasource.password=PePeFaFe!05\n</code></pre> <p>Nesse caso deve ser preenchido com o Usu\u00e1rio e senha mysql corretos, que foram criados ao configurar o ambiente do banco de dados na VM Database, tambem o ip de conex\u00e3o que nesse caso ser\u00e1 um ip resolvido pelo arquivo de hosts na VM Back-End, na porta liberada 3306.</p> <p>No host complete a build do projeto e mande o arquivo jar para o caminho correto na VM:</p> <pre><code>scp api.jar root@192.168.105:/opt/backend/\n</code></pre> <p>Tenha certeza de que o caminho que est\u00e1 tentando ser mandando o arquivo, realmente exista, caso o contr\u00e1rio falhar\u00e1.</p> <p>Agora j\u00e1 \u00e9 possivel testar o projeto executando o jar com o comando:</p> <pre><code>java -jar api.jar\n</code></pre> <p>Se todas as informa\u00e7\u00f5es de conex\u00e3o com o banco na projeto buildado estiverem corretas, e se o banco de dados estiver configurado corretamente, o projeto spring deve rodar sem nenhum erro.</p>"},{"location":"backend/#5-criando-o-script-para-rodar-a-api-automaticamente","title":"5. Criando o script para rodar a API automaticamente","text":"<p>Antes de criarmos o script, ser\u00e1 necess\u00e1rio criar um usu\u00e1rio dedicado apenas a rodar a API, pois n\u00e3o ser\u00e1 o <code>root</code> quem ir\u00e1 fazer isso:</p> <pre><code>adduser -h /opt/backend/ backend\n</code></pre> <p>Ser\u00e1 solicitado a senha e depois a confirma\u00e7\u00e3o da senha, usaremos: <code>PePeFaFe!05</code></p> <p>Definimos a home do user backend como sendo /opt/backend/ porque \u00e9 s\u00f3 ali que ele vai operar, rodando a API.</p> <p>Agora passamos para cria\u00e7\u00e3o do script, criamos o arquivo:</p> <pre><code>vi /etc/init.d/backend\n</code></pre> <p>E adicionamos ao script o seguinte conte\u00fado:</p> <pre><code>#!/sbin/openrc-run\n\ndescription=\"Lionlaw\"\njava=\"/usr/bin/java\"\narquivo=\"/opt/backend/api.jar\"\npidfile=\"/opt/backend/lionlaw.pid\"\noutput_log=\"/opt/backend/backend.out\"\nusuario=\"backend\"\n\ndepend() {\n    need net\n    after local\n}\n\nstart_pre() {\n    echo \"Iniciando Spring...\"\n}\n\nstart() {\n    cd /opt/backend || exit 1\n    su -s /bin/sh -c \"nohup $java -jar $arquivo &gt; $output_log 2&gt;&amp;1 &amp; echo \\$! &gt; $pidfile\" $usuario\n    echo \"Aguardando LionLaw Iniciar...\"\n    for i in $(seq 1 60); do\n        if netstat -tlnp 2&gt;/dev/null | grep -q \":8080 \"; then\n            echo \"Backend LionLaw iniciado!\"\n            return 0\n        fi\n        sleep 1\n    done\n    echo \"Falha ao iniciar LionLaw.\"\n    return 1\n}\n\nstop() {\n    echo \"Parando servi\u00e7o...\"\n    if [ -f \"$pidfile\" ]; then\n        kill -9 \"$(cat $pidfile)\" &amp;&amp; rm -f \"$pidfile\"\n        echo \"LionLaw parado.\"\n    else\n        echo \"Nenhum servi\u00e7o rodando na porta 8080.\"\n    fi\n}\n</code></pre> <p>Daremos permiss\u00e3o de execu\u00e7\u00e3o ao script:</p> <pre><code>chmod +x /etc/init.d/backend-api\n</code></pre> <p>Testar se o script inicia corretamente:</p> <pre><code>service backend start\n</code></pre> <p>E adicionar para iniciar automaticamente com o sistema:</p> <pre><code>rc-update add backend boot\n</code></pre> <p>Agora toda vez que iniciarmos essa VM, a API vai ser iniciada pelo user backend.</p>"},{"location":"backend/#6-configurarando-o-script-de-backup","title":"6. Configurarando o script de backup","text":"<p>Crie o arquivo de script em algum lugar seguro</p> <pre><code>vi /root/backup_backend\n</code></pre> <p>Criamos na pasta root, n\u00e3o h\u00e1 nada de sensivel no backup do back, mas no dump do banco \u00e9 necessario ter a senha e user mysql, oque \u00e9 importante proteger.</p> <p>Esse ser\u00e1 nosso script:</p> <pre><code>#!/bin/sh\n\n#Timestamp para identificar horario dos backups\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\n\n#Arquivo temporario, para organizar tudo\ntemp_dir=\"/tmp/backup_backend_$timestamp\"\n\n#Localiza\u00e7\u00e3o dos arquivos alvo do backup\ninit_script=\"/etc/init.d/backend\"\nauthorized_keys=\"/root/.ssh/authorized_keys\"\n\n#Local e nome do arquivo compactado tar gz\ntar_file=\"/tmp/backup_backend_$timestamp.tar.gz\"\n\n# Caminhos de destino\nremote_user=\"backup_sys\"\nremote_host=\"frontend.llw\"\nremote_path=\"/opt/backup/backend\"\n\necho \"Criando diret\u00f3rios tempor\u00e1rios, Data: $timestamp\"\nmkdir -p \"$temp_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Copiando script de inicializa\u00e7\u00e3o, Data: $timestamp\"\ncp \"$init_script\" \"$temp_dir/\" || { echo \"Erro ao copiar o script backend, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Copiando authorized_keys, Data: $timestamp\"\ncp \"$authorized_keys\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Compactando arquivos, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Enviando backup para $remote_host:$remote_path, Data: $timestamp\"\nscp \"$tar_file\" \"$remote_user@$remote_host:$remote_path/\" || { echo \"Erro ao enviar o backup via SCP, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$tar_file\"; exit 1; }\n\necho \"-&gt; Backup enviado com sucesso, Data: $timestamp\"\n\nrm -rf \"$temp_dir\" \"$tar_file\"\nexit 0\n</code></pre> <p>Torne-o executavel com o comando:</p> <pre><code>chmod +x /root/backup_backend\n</code></pre> <p>Agora j\u00e1 ser\u00e1 possivel chamar o script manualmente, /root/backup_backend.</p>"},{"location":"backend/#7-agendamento-de-script-backup-com-crontab","title":"7. Agendamento de Script Backup com Crontab","text":"<p>Edite o arquivo de agendamento do service padr\u00e3o do Linux Alpine com o codigo:</p> <pre><code>crontab -e\n</code></pre> <p>Dentro do arquivo adicione essa linha ao final:</p> <pre><code>0 */3 * * * /root/backup_backend 1&gt;&gt; /var/log/backup_backend.log 2&gt;&gt; /var/log/backup_backend_error.log\n</code></pre> <p>Essa linha garantir\u00e1 que o script ser\u00e1 executado no minuto 0 a cada 3 horas, e tamb\u00e9m redireciona a saida padr\u00e3o stdout 1&gt;&gt; para um arquivo de log, e a saida de erros stderr 2&gt;&gt; para um arquivo de log separado, apenas para erros.</p>"},{"location":"database/","title":"Configura\u00e7\u00e3o da VM Database","text":"<p>Este arquivo documenta, passo a passo, todo o processo de configura\u00e7\u00e3o da VM Database. Ela ser\u00e1 respons\u00e1vel por armazenar o banco de dados que ser\u00e1 utilizado pela API para armazenar as informa\u00e7\u00f5es necessarias para seu funcionamento, usaremos MariaDB como sgbd e para acesso e configura\u00e7\u00e3o do banco o mysql-client.</p>"},{"location":"database/#1-clonando-a-vm-base","title":"1. Clonando a VM Base","text":"<p>Come\u00e7aremos clonando a VM base, que j\u00e1 foi criada previamente. A configura\u00e7\u00e3o dessa VM base est\u00e1 documentada no Arquivo de configura\u00e7\u00e3o da VM base.</p>"},{"location":"database/#2-configuracoes-iniciais-da-vm-database","title":"2. Configura\u00e7\u00f5es Iniciais da VM Database","text":"<p>Antes de passar para as configura\u00e7\u00f5es dessa VM vamos personalizar a identidade dela e garantir que ela esteja preparada para se comunicar corretamente com as outras.</p>"},{"location":"database/#alterando-o-hostname","title":"Alterando o Hostname","text":"<p>Para diferenciar a VM Database das demais, alteraremos seu hostname para database, editando o arquivo:</p> <pre><code>vi /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"database/#definindo-uma-senha-segura-para-o-usuario-root","title":"Definindo uma senha segura para o usu\u00e1rio root","text":"<p>Se ainda n\u00e3o definiu uma senha forte para o root durante o setup da VM, fa\u00e7a-o:</p> <pre><code>passwd\n</code></pre> <p>Crie uma senha segura e guarde-a. Considere uma senha com no m\u00ednimo 12 caracteres, incluindo letras mai\u00fasculas, min\u00fasculas, n\u00fameros e s\u00edmbolos, j\u00e1 que viemos da VM-base, a senha antiga era root (nada seguro).</p>"},{"location":"database/#configurando-resolucao-de-ips-no-arquivo-etchosts","title":"Configurando resolu\u00e7\u00e3o de IPs no arquivo /etc/hosts","text":"<p>Para que o mariadb possa saber quem est\u00e1 se conectando a ela ajuste a resolu\u00e7\u00e3o de ip de hosts, por isso, edite o arquivo:</p> <pre><code>vi /etc/hosts\n</code></pre> <p>E adicione a resolu\u00e7\u00e3o do ip corretamente:</p> <pre><code>\"192.168.0.1\" backend.llw\n</code></pre> <p>O ip acima \u00e9 apenas um exemplo, coloque o ip da sua vm back-end no lugar daquele, e saiba que sempre que nessa documenta\u00e7\u00e3o for referida um ip com fim .llw significa que ele est\u00e1 resolvendo o ip de uma das VM's, Front, Back ou Database.</p> <p>Priorize um reboot da maquina, ap\u00f3s mudan\u00e7as no arquivo de hosts, porque por mais que \"n\u00e3o precise\", outros servi\u00e7os ler\u00e3o o arquivo de hosts somente na hora do boot, e n\u00e3o vao atualizando sua leitura, por isso nomes podem n\u00e3o ser resolvidos corretamente.</p> <p>Isso permite que a VM Front-End resolva o dom\u00ednio <code>backend.llw</code> para o IP especificado, facilitando poss\u00edveis mudan\u00e7as de IP no ambiente sem a necessidade de re-buildar o projeto.</p>"},{"location":"database/#3-instalando-mariadb","title":"3. Instalando MariaDB","text":"<p>Adicione o servi\u00e7o do MariaDB e todas suas depedencias, junto do cliente mysql:</p> <pre><code>apk add mariadb mysql-client\n</code></pre> <p>MariaDB ser\u00e1 nosso SGBD, mas o mysql-client ser\u00e1 usado para acessar a base de dados para, manuten\u00e7\u00e3o e configura\u00e7\u00e3o de usu\u00e1rios e permiss\u00f5es.</p> <p>Rode o script de setup do MariaDB com o comando:</p> <pre><code>/etc/init.d/mariadb setup\n</code></pre> <p>Agora edite o arquivo de configura\u00e7\u00e3o do MariaDB</p> <pre><code>vi /etc/my.cnf.d/mariadb-server.cnf\n</code></pre> <p>Modifique o conjunto de configura\u00e7\u00e3o do mysql:</p> <pre><code>[mysqld]\n#skip-networking\n\nbind-address=database.llw\nport=3306\n</code></pre> <p>Inicie e adicione o servi\u00e7o a nivel de boot, para inicar junto com o sistema:</p> <pre><code>rc-service mariadb start\nrc-update add mariadb boot\n</code></pre> <p>Ap\u00f3s esses passos o MariaDB vai rodar sempre que ligar VM, e vai receber conex\u00f5es de todas as interfaces de rede pela porta 3306.</p>"},{"location":"database/#4-configurando-o-ambiente-do-banco-de-dados","title":"4. Configurando o ambiente do Banco de Dados","text":"<p>Entrar no mysql-client utilizando o usuario root, sem senha (padr\u00e3o)</p> <pre><code>mysql -u root\n</code></pre> <p>Adicionaremos uma senha forte ao user root, por quest\u00f5es de seguran\u00e7a e requisito de projeto</p> <pre><code>ALTER USER 'root'@'localhost' IDENTIFIED BY 'PePeFaFe!05';\n</code></pre> <p>A senha do root ser\u00e1 a mesma do user advocacia por quest\u00f5es de facilitar a implementa\u00e7\u00e3o, mas deveriam ser distintas.</p> <p>Criar a base de dados utilizada pela API:</p> <pre><code>create database adv;\n</code></pre> <p>Agora criaremos o user mysql que ser\u00e1 utilizado pela API para acessar a database:</p> <pre><code>CREATE USER 'llw'@'backend.llw' IDENTIFIED BY 'PePeFaFe!05';\nGRANT SELECT,INSERT,UPDATE,DELETE ON adv.* TO 'llw'@'backend.llw';\n</code></pre> <p>Caso seja a primeira execu\u00e7\u00e3o do back, e o banco estiver vazio, pode ser necessario dar permiss\u00f5es de CREATE, mas lembre-se de remove-las depois com REVOKE.</p> <p>No fim esse usu\u00e1rio s\u00f3 ter\u00e1 permiss\u00e3o para operar na database que ser\u00e1 utilizada pela API, e s\u00f3 podera fazer comandos SQL limitados, nada que altere as estruturas das tabelas.</p>"},{"location":"database/#6-configurarando-o-script-de-backup","title":"6. Configurarando o script de backup","text":"<p>Crie o arquivo de script em algum lugar seguro</p> <pre><code>vi /root/backup_database\n</code></pre> <p>Criamos na pasta root pois o script ter\u00e1 a senha e user mysql, que \u00e9 importante proteger.</p> <p>Esse ser\u00e1 nosso script:</p> <pre><code>#!/bin/ash\n\n# Timestamp para identificar o backup\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\n\n#Arquivo temporario, para organizar tudo\ntemp_dir=\"/tmp/backup_database_$timestamp\"\n\n#Localiza\u00e7\u00e3o dos arquivos alvo do backup\ndump_file=\"/tmp/lionlaw_$timestamp.sql\"\nssh_key=\"/root/.ssh/authorized_keys\"\n\n#Local e nome do arquivo compactado tar gz\ntar_file=\"/tmp/backup_database_$timestamp.tar.gz\"\n\n# Caminhos de destino\nremote_user=\"backup_sys\"\nremote_host=\"frontend.llw\"\nremote_path=\"/opt/backup/database\"\n\n# Vari\u00e1veis do banco\ndb_user=\"USER\"\ndb_pass=\"SENHA\"\ndb_name=\"adv\"\n\necho \"Criando diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"\nmkdir -p \"$temp_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Realizando dump do banco de dados, , Data: $timestamp\"\nmariadb-dump -u\"$db_user\" -p\"$db_pass\" \"$db_name\" &gt; \"$dump_file\" || { echo \"Erro ao gerar o dump, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Copiando dump do banco de dados, Data: $timestamp\"\ncp \"$dump_file\" \"$temp_dir/\" || { echo \"Erro ao dump do banco de dados, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\n\ncp \"$ssh_key\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Compactando tudo, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar arquivos, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\"; exit 1; }\n\necho \"Enviando para $remote_user@$remote_host:$remote_path, Data $timestamp\"\nscp \"$tar_file\" \"$remote_user@$remote_host:$remote_path/\" || { echo \"Erro ao enviar o backup via SCP, Data: $timestamp\"; rm -rf \"$temp_dir\" \"$dump_file\" \"$tar_file\"; exit 1; }\n\necho \"-&gt; Backup enviado com sucesso, Data: $timestamp\"\n\nrm -rf \"$temp_dir\" \"$dump_file\" \"$tar_file\"\nexit 0\n</code></pre> <p>Torne-o executavel com o comando:</p> <pre><code>chmod +x /root/backup_database\n</code></pre> <p>Agora j\u00e1 ser\u00e1 possivel chamar o script manualmente, /root/backup_database.</p>"},{"location":"database/#7-agendamento-de-script-backup-com-crontab","title":"7. Agendamento de Script Backup com Crontab","text":"<p>Edite o arquivo de agendamento do service padr\u00e3o do Linux Alpine com o codigo:</p> <pre><code>crontab -e\n</code></pre> <p>Dentro do arquivo adicione essa linha ao final:</p> <pre><code>0 */6 * * * /root/backup_database 1&gt;&gt; /var/log/backup_database.log 2&gt;&gt; /var/log/backup_database_error.log\n</code></pre> <p>Essa linha garantir\u00e1 que o script ser\u00e1 executado no minuto 0 a cada 6 horas, e tamb\u00e9m redireciona a saida padr\u00e3o stdout 1&gt;&gt; para um arquivo de log, e a saida de erros stderr 2&gt;&gt; para um arquivo de log separado, apenas para erros.</p>"},{"location":"frontend/","title":"Configura\u00e7\u00e3o da VM Frontend","text":"<p>Este arquivo documenta, passo a passo, todo o processo de configura\u00e7\u00e3o da VM Front-End. Ela ser\u00e1 respons\u00e1vel por hospedar a interface do sistema utilizando o nginx, e tamb\u00e9m atuar\u00e1 como servidor de backups, armazenando os arquivos de backup de todas as outras VMs \u2014 incluindo ela mesma. Por esse motivo, esta VM tambem possuir\u00e1 a chave p\u00fablica RSA de cada uma das outras m\u00e1quinas virtuais em seu usu\u00e1rio backup_sys, que tambem ser\u00e1 o usuario que em sua home ter\u00e1 os arquivos de backup.</p>"},{"location":"frontend/#1-clonando-a-vm-base","title":"1. Clonando a VM Base","text":"<p>Come\u00e7aremos clonando a VM base, que j\u00e1 foi criada previamente. A configura\u00e7\u00e3o dessa VM base est\u00e1 documentada no Arquivo de configura\u00e7\u00e3o da VM base.</p>"},{"location":"frontend/#2-configuracoes-iniciais-da-vm-front-end","title":"2. Configura\u00e7\u00f5es Iniciais da VM Front-End","text":"<p>Antes de passar para as configura\u00e7\u00f5es dessa VM vamos personalizar a identidade dela e garantir que ela esteja preparada para se comunicar corretamente com as outras.</p>"},{"location":"frontend/#alterando-o-hostname","title":"Alterando o Hostname","text":"<p>Para diferenciar a VM Front-End das demais, alteraremos seu hostname para frontend, editando o arquivo:</p> <pre><code>vi /etc/hostname\n</code></pre> <p>As altera\u00e7\u00f5es no hostname s\u00f3 t\u00eam efeito ap\u00f3s um reboot:</p>"},{"location":"frontend/#definindo-uma-senha-segura-para-o-usuario-root","title":"Definindo uma senha segura para o usu\u00e1rio root","text":"<p>Se ainda n\u00e3o definiu uma senha forte para o root durante o setup da VM, fa\u00e7a-o:</p> <pre><code>passwd\n</code></pre> <p>Crie uma senha segura e guarde-a. Considere uma senha com no m\u00ednimo 12 caracteres, incluindo letras mai\u00fasculas, min\u00fasculas, n\u00fameros e s\u00edmbolos, j\u00e1 que viemos da VM-base, a senha antiga era root (nada seguro).</p>"},{"location":"frontend/#configurando-resolucao-de-ips-no-arquivo-etchosts","title":"Configurando resolu\u00e7\u00e3o de IPs no arquivo /etc/hosts","text":"<p>Mesmo com o backend funcional, o Front-End pode falhar nas requisi\u00e7\u00f5es caso o dom\u00ednio <code>backend.llw</code> (no nosso caso utilizado para o front fazer requisi\u00e7\u00f5es) n\u00e3o esteja sendo resolvido corretamente. Para resolver isso, edite o arquivo:</p> <pre><code>vi /etc/hosts\n</code></pre> <p>E adicione a resolu\u00e7\u00e3o do ip corretamente:</p> <pre><code>\"192.168.0.1\" backend.llw\n</code></pre> <p>O ip acima \u00e9 apenas um exemplo, coloque o ip da sua vm back-end no lugar daquele, e saiba que sempre que nessa documenta\u00e7\u00e3o for referida um ip com fim .llw significa que ele est\u00e1 resolvendo o ip de uma das VM's, Front, Back ou Database.</p> <p>Priorize um reboot da maquina, ap\u00f3s mudan\u00e7as no arquivo de hosts, porque por mais que \"n\u00e3o precise\", outros servi\u00e7os ler\u00e3o o arquivo de hosts somente na hora do boot, e n\u00e3o vao atualizando sua leitura, por isso nomes podem n\u00e3o ser resolvidos corretamente.</p> <p>Isso permite que a VM Front-End resolva o dom\u00ednio <code>backend.llw</code> para o IP especificado, facilitando poss\u00edveis mudan\u00e7as de IP no ambiente sem a necessidade de re-buildar o projeto.</p>"},{"location":"frontend/#adicionando-resolucao-no-host-windows","title":"Adicionando resolu\u00e7\u00e3o no host (Windows)","text":"<p>Mesmo com o front rodando na VM, o navegador que acessa o sistema est\u00e1 no host. Por isso, tamb\u00e9m \u00e9 necess\u00e1rio configurar essa resolu\u00e7\u00e3o no Windows:</p> <p>Edite o arquivo:</p> <pre><code>C:\\Windows\\System32\\drivers\\etc\\hosts\n</code></pre> <p>E adicione a mesma linha:</p> <pre><code>192.168.1.106 backend.llw\n</code></pre> <p>Lembre-se de abrir o editor de texto como Administrador para conseguir salvar as altera\u00e7\u00f5es nesse arquivo.</p>"},{"location":"frontend/#3-instalando-o-nginx","title":"3. Instalando o Nginx","text":"<p>Adicione o servi\u00e7o nginx e todas suas depedencias:</p> <pre><code>apk add nginx\n</code></pre> <p>Inicie e adicione o servi\u00e7o a nivel de boot, para inicar junto com o sistema:</p> <pre><code>rc-service nginx start\nrc-update add nginx boot\n</code></pre> <p>Ap\u00f3s essas mudan\u00e7as ja deve ser possivel acessar o ip da VM em seu navegador, e visualizar a p\u00e1gina 404 padr\u00e3o do nginx.</p>"},{"location":"frontend/#4-configurando-o-nginx","title":"4. Configurando o Nginx","text":"<p>Edite o arquivo de configura\u00e7\u00e3o do nginx:</p> <pre><code>vi /etc/nginx/http.d/default.conf\n</code></pre> <p>Adicione logs de acesso e de erros, para melhor rastrear e resoluciona-los (Opcional)</p> <pre><code>access_log /var/log/nginx/frontend_access.log;\nerror_log /var/log/nginx/frontend_error.log;\n</code></pre> <p>Modifique o conte\u00fado do bloco location / { ... }:</p> <pre><code>location / {\n    root /opt/frontend;\n    index index.html;\n    try_files $uri $uri/ /index.html;\n}\n</code></pre> <p>Adicione o caminho que ira ficar os arquivos do front na linha root e o nome do index na linha index, o try_files retornar para index \u00e9 necess\u00e1rio para aplica\u00e7\u00f5es SPA, como no nosso caso de um projeto com front em Angular.</p> <p>Recarregue o nginx para que ele reconhe\u00e7a as modifica\u00e7\u00f5es feitas no arquivo de configura\u00e7\u00e3o:</p> <pre><code>service nginx reload\n</code></pre>"},{"location":"frontend/#5-buildando-o-front-end","title":"5. Buildando o Front-End","text":"<p>Antes de fazer o build do front, \u00e9 necess\u00e1rio configurar corretamente o endere\u00e7o IP da API Back-End que ser\u00e1 utilizado.</p>"},{"location":"frontend/#arquivos-de-ambiente-no-angular","title":"Arquivos de ambiente no Angular:","text":"<p>O Angular geralmente possui arquivos em:</p> <ul> <li><code>src/environments/environment.ts</code> (usado em desenvolvimento)</li> <li><code>src/environments/environment.server.ts</code> (usado em produ\u00e7\u00e3o ou build final)</li> </ul> <p>No arquivo <code>environment.server.ts</code>, altere o campo <code>apiUrl</code> para o IP que ser\u00e1 resolvido pela VM Front-End, por exemplo:</p> <pre><code>export const environment = {\n  production: true,\n  apiUrl: 'http://backend.llw:8080' // IP da VM Back-End\n};\n</code></pre> <p>Finalize a build do Projeto e compacte os arquivos em zip, pois \u00e9 uma extens\u00e3o que Linux consegue lidar nativamente.</p> <p>Agora no host envie o arquivo zip via ssh para a VM no caminho que foi definido no arquivo de configura\u00e7\u00e3o do nginx:</p> <pre><code>scp site.zip root@192.168.1.105:/opt/frontend/\n</code></pre> <p>Tenha certeza de que o caminho que est\u00e1 tentando ser mandando o arquivo, realmente exista, caso o contr\u00e1rio falhar\u00e1.</p> <p>Na VM descompacte o arquivo usando o comando:</p> <pre><code>unzip site.zip\n</code></pre> <p>Agora j\u00e1 deve ser possivel visualizar a tela inicial do projeto ao acessar o endere\u00e7o de ip da VM no navegador.</p>"},{"location":"frontend/#6-preparando-o-ambiente-para-o-backup","title":"6. Preparando o ambiente para o backup","text":"<p>Primeiramente vamos criar o arquivo onde ficar\u00e1 armazenado os backups:</p> <pre><code>mkdir /opt/backup/\n</code></pre> <p>Tambem vamos criar as pastas para sub-categorizar os backups:</p> <pre><code>mkdir /opt/backup/frontend/\nmkdir /opt/backup/backend/\nmkdir /opt/backup/database/\n</code></pre> <p>Ap\u00f3s isso podemos criar o usuario backup_sys:</p> <pre><code>adduser -h /opt/backup/ backup_sys\n</code></pre> <p>Definimos a home do user backup_sys como sendo /opt/backup/ porque \u00e9 s\u00f3 la onde ele vai operar, recebendo os backups</p>"},{"location":"frontend/#7-recebendo-as-chaves-rsa-das-outras-vms","title":"7. Recebendo as chaves RSA das outras VM's:","text":"<p>Na VM Back-End e Database crie as chaves RSA (caso n\u00e3o possuam):</p> <pre><code>ssh-keygen -t rsa -b 4096\n</code></pre> <p>Agora em uma das VM's (Back-End ou Database) enviamos a chave com scp:</p> <pre><code>scp /root/.ssh/id_rsa.pub backup_sys@frontend.llw:/opt/backup/.ssh/authorized_keys\n</code></pre> <p>Ser\u00e1 necessario permitir conex\u00f5es ssh por senha de novo (na VM Front) para permitir o envio das chaves, mas temporariamente, desative depois.</p> <p>Agora na outra VM, envie o arquivo tambem, mas dessa vez n\u00e3o use scp, e tamb\u00e9m envie ela como uma chave tempor\u00e1ria:</p> <pre><code>scp /root/.ssh\\id_rsa.pub backup_sys@frontend.llw:/opt/backup/.ssh/tempkey.pub\n</code></pre> <p>Na VM Front-End, utilize o codigo para adicionar a chave temporaria ao final da outra:</p> <pre><code>cat /opt/backup/.ssh/tempkey.pub &gt;&gt; /opt/backup/.ssh/authorized_keys\n</code></pre> <p>Depois remova a chave temporaria:</p> <pre><code>rm /opt/backup/.ssh/tempkey.pub\n</code></pre> <p>Isso \u00e9 necessario pois o comando scp, sobrescreve qualquer arquivo que j\u00e1 exista com o mesmo nome, ent\u00e3o se mandassemos uma chave com o nome de authorized_keys, e depois mandassemos a outra da mesma forma, a segunda iria sobrescrever a primeira, dessa forma voc\u00ea enfileira uma atras da outra dentro do mesmo arquivo sem perder nenhuma.</p> <p>Para finalizar modifique as permiss\u00f5es da chave:</p> <pre><code>chmod 600 /opt/backup/.ssh/authorized_keys\n</code></pre> <p>E tambem mude o dono da pasta .ssh na home do user backup:</p> <pre><code>chown -R backup_sys:backup_sys /opt/backup/.ssh\n</code></pre> <p>Isso \u00e9 necessario porque, por mais que a pasta esteja na home do usuario backup, o root ainda \u00e9 dono dela, assim essa chave s\u00f3 ser\u00e1 valida, quando conex\u00f5es a essa maquina forem pelo usuario backup_sys.</p>"},{"location":"frontend/#8-configurarando-o-script-de-backup-local","title":"8. Configurarando o script de backup local","text":"<p>Crie o arquivo de script em algum lugar seguro</p> <pre><code>vi /root/backup_front\n</code></pre> <p>Criamos na pasta root, n\u00e3o h\u00e1 nada de sensivel no backup do front, mas no dump do banco \u00e9 necessario ter a senha e user mysql, oque \u00e9 importante proteger.</p> <p>Esse ser\u00e1 nosso script:</p> <pre><code>#!/bin/sh\n\n#Timestamp para identificar horario dos backups\ntimestamp=$(date '+%Y-%m-%d_%H-%M-%S')\n\n#Arquivo temporario, para organizar tudo\ntemp_dir=\"/tmp/backup_front_$timestamp\"\n\n#Arquivo para os itens do front ficarem dentro\nfront_dir=\"$temp_dir/front\"\n\n#Localiza\u00e7\u00e3o dos arquivos alvo do backup\nfront_end=\"/opt/frontend\"\nauthorized_keys=\"/root/.ssh/authorized_keys\"\n\n#Local e nome do arquivo compactado tar gz\ntar_file=\"/opt/backup/frontend/backup_front_$timestamp.tar.gz\"\n\necho \"Criando diret\u00f3rios tempor\u00e1rios, Data: $timestamp\"\nmkdir -p \"$front_dir\" || { echo \"Erro ao criar diret\u00f3rio tempor\u00e1rio, Data: $timestamp\"; exit 1; }\n\necho \"Copiando arquivos do frontend, Data: $timestamp\"\ncp -r \"$front_end/\"* \"$front_dir/\" || { echo \"Erro ao copiar arquivos do frontend, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Copiando authorized_keys, Data: $timestamp\"\ncp \"$authorized_keys\" \"$temp_dir/\" || { echo \"Erro ao copiar authorized_keys, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"Compactando tudo, Data: $timestamp\"\ntar -czf \"$tar_file\" -C \"$(dirname \"$temp_dir\")\" \"$(basename \"$temp_dir\")\" || { echo \"Erro ao compactar, Data: $timestamp\"; rm -rf \"$temp_dir\"; exit 1; }\n\necho \"-&gt; Backup criado com sucesso, Data: $timestamp \"\n\nrm -rf \"$temp_dir\"\nexit 0\n</code></pre> <p>Torne-o executavel com o comando:</p> <pre><code>chmod +x /root/backup_front\n</code></pre> <p>Agora j\u00e1 ser\u00e1 possivel chamar o script manualmente, /root/backup_front.</p>"},{"location":"frontend/#9-agendamento-de-script-backup-com-crontab","title":"9. Agendamento de Script Backup com Crontab","text":"<p>Edite o arquivo de agendamento padr\u00e3o do Linux Alpine com o codigo:</p> <pre><code>crontab -e\n</code></pre> <p>Dentro do arquivo adicione essa linha ao final:</p> <pre><code>0 */3 * * * /root/backup_front 1&gt;&gt; /var/log/backup_front.log 2&gt;&gt; /var/log/backup_front_error.log\n</code></pre> <p>Essa linha garantir\u00e1 que o script ser\u00e1 executado no minuto 0 a cada 3 horas, e tamb\u00e9m redireciona a saida padr\u00e3o stdout 1&gt;&gt; para um arquivo de log, e a saida de erros stderr 2&gt;&gt; para um arquivo de log separado, apenas para erros.</p>"}]}